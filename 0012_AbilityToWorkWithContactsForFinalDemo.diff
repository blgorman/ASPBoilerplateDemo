diff --git a/src/MGS.BoilerplateDemo.Application/BoilerplateDemo/Contacts/ContactAppService.cs b/src/MGS.BoilerplateDemo.Application/BoilerplateDemo/Contacts/ContactAppService.cs
new file mode 100644
index 0000000..af49a89
--- /dev/null
+++ b/src/MGS.BoilerplateDemo.Application/BoilerplateDemo/Contacts/ContactAppService.cs
@@ -0,0 +1,47 @@
+﻿using System.Threading.Tasks;
+using Abp.Application.Services;
+using Abp.Application.Services.Dto;
+using Abp.Authorization;
+using Abp.Domain.Repositories;
+using MGS.BoilerplateDemo.Authorization;
+using MGS.BoilerplateDemo.BoilerplateDemo.Contacts.Dtos;
+
+namespace MGS.BoilerplateDemo.BoilerplateDemo.Contacts
+{
+    [AbpAuthorize(PermissionNames.Pages_Contacts)]
+    public class ContactAppService : AsyncCrudAppService<Contact, ContactListViewDto, int, GetContactDto, ContactCreateOrEditDto, ContactCreateOrEditDto>, IContactAppService
+    {
+        public ContactAppService(IRepository<Contact, int> repository) : base(repository)
+        {
+
+        }
+
+        [AbpAuthorize(PermissionNames.Pages_Contacts_Create)]
+        public override Task<ContactListViewDto> Create(ContactCreateOrEditDto input)
+        {
+            return base.Create(input);
+        }
+
+        [AbpAuthorize(PermissionNames.Pages_Contacts_Delete)]
+        public override Task Delete(EntityDto<int> input)
+        {
+            return base.Delete(input);
+        }
+
+        public override Task<ContactListViewDto> Get(EntityDto<int> input)
+        {
+            return base.Get(input);
+        }
+
+        public override Task<PagedResultDto<ContactListViewDto>> GetAll(GetContactDto input)
+        {
+            return base.GetAll(input);
+        }
+
+        [AbpAuthorize(PermissionNames.Pages_Contacts_Update)]
+        public override Task<ContactListViewDto> Update(ContactCreateOrEditDto input)
+        {
+            return base.Update(input);
+        }
+    }
+}
diff --git a/src/MGS.BoilerplateDemo.Application/BoilerplateDemo/Contacts/Dtos/ContactCreateOrEditDto.cs b/src/MGS.BoilerplateDemo.Application/BoilerplateDemo/Contacts/Dtos/ContactCreateOrEditDto.cs
new file mode 100644
index 0000000..57d1121
--- /dev/null
+++ b/src/MGS.BoilerplateDemo.Application/BoilerplateDemo/Contacts/Dtos/ContactCreateOrEditDto.cs
@@ -0,0 +1,31 @@
+﻿using Abp.Application.Services.Dto;
+using Abp.AutoMapper;
+using Abp.Domain.Entities;
+using System;
+using System.Collections.Generic;
+using System.ComponentModel.DataAnnotations;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace MGS.BoilerplateDemo.BoilerplateDemo.Contacts.Dtos
+{
+    [AutoMap(typeof(Contact))]
+    public class ContactCreateOrEditDto : EntityDto, IMustHaveTenant, IPassivable
+    {
+        [Required]
+        public string FirstName { get; set; }
+        [Required]
+        public string LastName { get; set; }
+        [Required(ErrorMessage = "Email is required")]
+        [DataType(DataType.EmailAddress, ErrorMessage = "E-mail is not valid")]
+        public string Email { get; set; }
+
+        [Required]
+        public int StateId { get; set; }
+
+        public int TenantId { get; set; }
+        public bool IsActive { get; set; }
+        public int? TitleId { get; set; }
+    }
+}
diff --git a/src/MGS.BoilerplateDemo.Application/BoilerplateDemo/Contacts/Dtos/ContactListViewDto.cs b/src/MGS.BoilerplateDemo.Application/BoilerplateDemo/Contacts/Dtos/ContactListViewDto.cs
new file mode 100644
index 0000000..9e8021d
--- /dev/null
+++ b/src/MGS.BoilerplateDemo.Application/BoilerplateDemo/Contacts/Dtos/ContactListViewDto.cs
@@ -0,0 +1,42 @@
+﻿using Abp.Application.Services.Dto;
+using Abp.AutoMapper;
+using MGS.BoilerplateDemo.BoilerplateDemo.OptionListAndListItems.Dtos;
+using System;
+using System.Collections.Generic;
+using System.ComponentModel.DataAnnotations;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace MGS.BoilerplateDemo.BoilerplateDemo.Contacts.Dtos
+{
+    [AutoMap(typeof(Contact))]
+    public class ContactListViewDto : EntityDto
+    {
+        public virtual OptionListItemViewDto Title { get; set; }
+        public int? TitleId { get; set; }
+        public string TitleDisplay => Title?.DisplayText; 
+
+        [Required]
+        public string FirstName { get; set; }
+        [Required]
+        public string LastName { get; set; }
+        [Required(ErrorMessage = "Email is required")]
+        [DataType(DataType.EmailAddress, ErrorMessage = "E-mail is not valid")]
+        public string Email { get; set; }
+
+        //make the State Required
+        public virtual OptionListItemViewDto State { get; set; }
+        [Required]
+        public int StateId { get; set; }
+        public string StateDisplay => State?.DisplayText;
+
+        /* TODO: Other contact fields not relevant to demo */
+
+        [Required]
+        public int TenantId { get; set; }
+        public bool IsActive { get; set; }
+
+        public string DisplayName => $"{LastName}, {FirstName}";
+    }
+}
diff --git a/src/MGS.BoilerplateDemo.Application/BoilerplateDemo/Contacts/Dtos/GetContactDto.cs b/src/MGS.BoilerplateDemo.Application/BoilerplateDemo/Contacts/Dtos/GetContactDto.cs
new file mode 100644
index 0000000..2e32de6
--- /dev/null
+++ b/src/MGS.BoilerplateDemo.Application/BoilerplateDemo/Contacts/Dtos/GetContactDto.cs
@@ -0,0 +1,16 @@
+﻿using Abp.Application.Services.Dto;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace MGS.BoilerplateDemo.BoilerplateDemo.Contacts.Dtos
+{
+    public class GetContactDto : PagedAndSortedResultRequestDto
+    {
+        public string Filter { get; set; }
+
+        public string Key { get; set; }
+    }
+}
diff --git a/src/MGS.BoilerplateDemo.Application/BoilerplateDemo/Contacts/IContactAppService.cs b/src/MGS.BoilerplateDemo.Application/BoilerplateDemo/Contacts/IContactAppService.cs
new file mode 100644
index 0000000..d20fda2
--- /dev/null
+++ b/src/MGS.BoilerplateDemo.Application/BoilerplateDemo/Contacts/IContactAppService.cs
@@ -0,0 +1,15 @@
+﻿using Abp.Application.Services;
+using MGS.BoilerplateDemo.BoilerplateDemo.Contacts.Dtos;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace MGS.BoilerplateDemo.BoilerplateDemo.Contacts
+{
+    public interface IContactAppService : IAsyncCrudAppService<ContactListViewDto, int, GetContactDto, ContactCreateOrEditDto, ContactCreateOrEditDto>
+    {
+        
+    }
+}
diff --git a/src/MGS.BoilerplateDemo.Core/Authorization/BoilerplateDemoAuthorizationProvider.cs b/src/MGS.BoilerplateDemo.Core/Authorization/BoilerplateDemoAuthorizationProvider.cs
index 9f706b5..cb4839a 100644
--- a/src/MGS.BoilerplateDemo.Core/Authorization/BoilerplateDemoAuthorizationProvider.cs
+++ b/src/MGS.BoilerplateDemo.Core/Authorization/BoilerplateDemoAuthorizationProvider.cs
@@ -36,6 +36,11 @@ namespace MGS.BoilerplateDemo.Authorization
             tenantOptionListItems.CreateChildPermission(PermissionNames.Pages_OptionListItems_Update, L("OptionListItemsUpdate"), multiTenancySides: MultiTenancySides.Tenant);
             tenantOptionListItems.CreateChildPermission(PermissionNames.Pages_OptionListItems_Delete, L("OptionListItemsDelete"), multiTenancySides: MultiTenancySides.Tenant);
 
+            var tenantContacts = pages.CreateChildPermission(PermissionNames.Pages_Contacts, L("Contacts"), multiTenancySides: MultiTenancySides.Tenant);
+            tenantContacts.CreateChildPermission(PermissionNames.Pages_Contacts_Create, L("ContactsCreate"), multiTenancySides: MultiTenancySides.Tenant);
+            tenantContacts.CreateChildPermission(PermissionNames.Pages_Contacts_Update, L("ContactsUpdate"), multiTenancySides: MultiTenancySides.Tenant);
+            tenantContacts.CreateChildPermission(PermissionNames.Pages_Contacts_Delete, L("ContactsDelete"), multiTenancySides: MultiTenancySides.Tenant);
+
         }
 
         private static ILocalizableString L(string name)
diff --git a/src/MGS.BoilerplateDemo.Core/Authorization/PermissionNames.cs b/src/MGS.BoilerplateDemo.Core/Authorization/PermissionNames.cs
index ce2f906..3a61106 100644
--- a/src/MGS.BoilerplateDemo.Core/Authorization/PermissionNames.cs
+++ b/src/MGS.BoilerplateDemo.Core/Authorization/PermissionNames.cs
@@ -35,5 +35,11 @@
         public const string Pages_OptionListItems_Create = "Pages.OptionListItems.Create";
         public const string Pages_OptionListItems_Update = "Pages.OptionListItems.Update";
         public const string Pages_OptionListItems_Delete = "Pages.OptionListItems.Delete";
+
+        //Contacts
+        public const string Pages_Contacts = "Pages.Contacts";
+        public const string Pages_Contacts_Create = "Pages.Contacts.Create";
+        public const string Pages_Contacts_Update = "Pages.Contacts.Update";
+        public const string Pages_Contacts_Delete = "Pages.Contacts.Delete";
     }
 }
diff --git a/src/MGS.BoilerplateDemo.Core/BoilerplateDemo/Contacts/Contact.cs b/src/MGS.BoilerplateDemo.Core/BoilerplateDemo/Contacts/Contact.cs
new file mode 100644
index 0000000..e62d1f7
--- /dev/null
+++ b/src/MGS.BoilerplateDemo.Core/BoilerplateDemo/Contacts/Contact.cs
@@ -0,0 +1,41 @@
+﻿using Abp.Domain.Entities;
+using Abp.Domain.Entities.Auditing;
+using MGS.BoilerplateDemo.BoilerplateDemo.OptionListsAndListItems;
+using System;
+using System.Collections.Generic;
+using System.ComponentModel.DataAnnotations;
+using System.ComponentModel.DataAnnotations.Schema;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace MGS.BoilerplateDemo.BoilerplateDemo.Contacts
+{
+    public class Contact : FullAuditedEntity, IPassivable, IMustHaveTenant
+    {
+        //an optional local list item
+        [ForeignKey("TitleId")]
+        public virtual OptionListItem Title { get; set; }
+        public int? TitleId { get; set; }
+
+        [Required]
+        public string FirstName { get; set; }
+        [Required]
+        public string LastName { get; set; }
+        [Required(ErrorMessage = "Email is required")]
+        [DataType(DataType.EmailAddress, ErrorMessage = "E-mail is not valid")]
+        public string Email { get; set; }
+
+        //make the State Required
+        [ForeignKey("StateId")]
+        public virtual OptionListItem State { get; set; }
+        [Required]
+        public int StateId { get; set; }
+
+        /* TODO: Other contact fields not relevant to demo */
+
+        [Required]
+        public int TenantId { get; set; }
+        public bool IsActive { get; set; }
+    }
+}
diff --git a/src/MGS.BoilerplateDemo.Core/Localization/SourceFiles/BoilerplateDemo.xml b/src/MGS.BoilerplateDemo.Core/Localization/SourceFiles/BoilerplateDemo.xml
index a8273e6..3c79c98 100644
--- a/src/MGS.BoilerplateDemo.Core/Localization/SourceFiles/BoilerplateDemo.xml
+++ b/src/MGS.BoilerplateDemo.Core/Localization/SourceFiles/BoilerplateDemo.xml
@@ -127,5 +127,12 @@
     <text name="AdministrationMenu">Administration</text>
     <text name="OptionListsMenu">Option Lists</text>
     <text name="OptionListItemsMenu">Option List Items</text>
+    
+    <!-- Contacts -->
+    <text name="Contacts">Contacts</text>
+    <text name="ContactsCreate">Create Contacts</text>
+    <text name="ContactsUpdate">Update Contacts</text>
+    <text name="ContactsDelete">Delete Contacts</text>
+    <text name="ContactsMenu">Contacts</text>
   </texts>
 </localizationDictionary>
diff --git a/src/MGS.BoilerplateDemo.EntityFrameworkCore/EntityFrameworkCore/BoilerplateDemoDbContext.cs b/src/MGS.BoilerplateDemo.EntityFrameworkCore/EntityFrameworkCore/BoilerplateDemoDbContext.cs
index 58d25e1..09083a9 100644
--- a/src/MGS.BoilerplateDemo.EntityFrameworkCore/EntityFrameworkCore/BoilerplateDemoDbContext.cs
+++ b/src/MGS.BoilerplateDemo.EntityFrameworkCore/EntityFrameworkCore/BoilerplateDemoDbContext.cs
@@ -4,6 +4,7 @@ using MGS.BoilerplateDemo.Authorization.Roles;
 using MGS.BoilerplateDemo.Authorization.Users;
 using MGS.BoilerplateDemo.MultiTenancy;
 using MGS.BoilerplateDemo.BoilerplateDemo.OptionListsAndListItems;
+using MGS.BoilerplateDemo.BoilerplateDemo.Contacts;
 
 namespace MGS.BoilerplateDemo.EntityFrameworkCore
 {
@@ -13,6 +14,8 @@ namespace MGS.BoilerplateDemo.EntityFrameworkCore
         public virtual DbSet<OptionList> OptionLists { get; set; }
         public virtual DbSet<OptionListItem> OptionListItems { get; set; }
 
+        public virtual DbSet<Contact> Contacts { get; set; }
+
         public BoilerplateDemoDbContext(DbContextOptions<BoilerplateDemoDbContext> options)
             : base(options)
         {
diff --git a/src/MGS.BoilerplateDemo.EntityFrameworkCore/MGS.BoilerplateDemo.EntityFrameworkCore.csproj b/src/MGS.BoilerplateDemo.EntityFrameworkCore/MGS.BoilerplateDemo.EntityFrameworkCore.csproj
index 0fc9a49..2746c0c 100644
--- a/src/MGS.BoilerplateDemo.EntityFrameworkCore/MGS.BoilerplateDemo.EntityFrameworkCore.csproj
+++ b/src/MGS.BoilerplateDemo.EntityFrameworkCore/MGS.BoilerplateDemo.EntityFrameworkCore.csproj
@@ -13,6 +13,12 @@
     <Compile Remove="Migrations\20190111071724_Upgraded_To_Abp_v4_1_0.cs" />
     <Compile Remove="Migrations\20190507051524_AddOptionListAndOptionListItemsEntities.cs" />
     <Compile Remove="Migrations\20190507051524_AddOptionListAndOptionListItemsEntities.Designer.cs" />
+    <Compile Remove="Migrations\20190519024739_Create Contact Object for Demo.cs" />
+    <Compile Remove="Migrations\20190519024739_Create Contact Object for Demo.Designer.cs" />
+    <Compile Remove="Migrations\20190519024847_Create Contact Object for Demo.cs" />
+    <Compile Remove="Migrations\20190519024847_Create Contact Object for Demo.Designer.cs" />
+    <Compile Remove="Migrations\20190519025356_Create Contact Object for Demo.cs" />
+    <Compile Remove="Migrations\20190519025356_Create Contact Object for Demo.Designer.cs" />
   </ItemGroup>
   <ItemGroup>
     <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="2.2.1" />
diff --git a/src/MGS.BoilerplateDemo.EntityFrameworkCore/Migrations/20190519030513_Create Contact Object for Demo.Designer.cs b/src/MGS.BoilerplateDemo.EntityFrameworkCore/Migrations/20190519030513_Create Contact Object for Demo.Designer.cs
new file mode 100644
index 0000000..6312f20
--- /dev/null
+++ b/src/MGS.BoilerplateDemo.EntityFrameworkCore/Migrations/20190519030513_Create Contact Object for Demo.Designer.cs	
@@ -0,0 +1,1429 @@
+﻿// <auto-generated />
+using System;
+using MGS.BoilerplateDemo.EntityFrameworkCore;
+using Microsoft.EntityFrameworkCore;
+using Microsoft.EntityFrameworkCore.Infrastructure;
+using Microsoft.EntityFrameworkCore.Metadata;
+using Microsoft.EntityFrameworkCore.Migrations;
+using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
+
+namespace MGS.BoilerplateDemo.Migrations
+{
+    [DbContext(typeof(BoilerplateDemoDbContext))]
+    [Migration("20190519030513_Create Contact Object for Demo")]
+    partial class CreateContactObjectforDemo
+    {
+        protected override void BuildTargetModel(ModelBuilder modelBuilder)
+        {
+#pragma warning disable 612, 618
+            modelBuilder
+                .HasAnnotation("ProductVersion", "2.2.1-servicing-10028")
+                .HasAnnotation("Relational:MaxIdentifierLength", 128)
+                .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+            modelBuilder.Entity("Abp.Application.Editions.Edition", b =>
+                {
+                    b.Property<int>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<long?>("DeleterUserId");
+
+                    b.Property<DateTime?>("DeletionTime");
+
+                    b.Property<string>("DisplayName")
+                        .IsRequired()
+                        .HasMaxLength(64);
+
+                    b.Property<bool>("IsDeleted");
+
+                    b.Property<DateTime?>("LastModificationTime");
+
+                    b.Property<long?>("LastModifierUserId");
+
+                    b.Property<string>("Name")
+                        .IsRequired()
+                        .HasMaxLength(32);
+
+                    b.HasKey("Id");
+
+                    b.ToTable("AbpEditions");
+                });
+
+            modelBuilder.Entity("Abp.Application.Features.FeatureSetting", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<string>("Discriminator")
+                        .IsRequired();
+
+                    b.Property<string>("Name")
+                        .IsRequired()
+                        .HasMaxLength(128);
+
+                    b.Property<int?>("TenantId");
+
+                    b.Property<string>("Value")
+                        .IsRequired()
+                        .HasMaxLength(2000);
+
+                    b.HasKey("Id");
+
+                    b.ToTable("AbpFeatures");
+
+                    b.HasDiscriminator<string>("Discriminator").HasValue("FeatureSetting");
+                });
+
+            modelBuilder.Entity("Abp.Auditing.AuditLog", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<string>("BrowserInfo")
+                        .HasMaxLength(512);
+
+                    b.Property<string>("ClientIpAddress")
+                        .HasMaxLength(64);
+
+                    b.Property<string>("ClientName")
+                        .HasMaxLength(128);
+
+                    b.Property<string>("CustomData")
+                        .HasMaxLength(2000);
+
+                    b.Property<string>("Exception")
+                        .HasMaxLength(2000);
+
+                    b.Property<int>("ExecutionDuration");
+
+                    b.Property<DateTime>("ExecutionTime");
+
+                    b.Property<int?>("ImpersonatorTenantId");
+
+                    b.Property<long?>("ImpersonatorUserId");
+
+                    b.Property<string>("MethodName")
+                        .HasMaxLength(256);
+
+                    b.Property<string>("Parameters")
+                        .HasMaxLength(1024);
+
+                    b.Property<string>("ReturnValue");
+
+                    b.Property<string>("ServiceName")
+                        .HasMaxLength(256);
+
+                    b.Property<int?>("TenantId");
+
+                    b.Property<long?>("UserId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("TenantId", "ExecutionDuration");
+
+                    b.HasIndex("TenantId", "ExecutionTime");
+
+                    b.HasIndex("TenantId", "UserId");
+
+                    b.ToTable("AbpAuditLogs");
+                });
+
+            modelBuilder.Entity("Abp.Authorization.PermissionSetting", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<string>("Discriminator")
+                        .IsRequired();
+
+                    b.Property<bool>("IsGranted");
+
+                    b.Property<string>("Name")
+                        .IsRequired()
+                        .HasMaxLength(128);
+
+                    b.Property<int?>("TenantId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("TenantId", "Name");
+
+                    b.ToTable("AbpPermissions");
+
+                    b.HasDiscriminator<string>("Discriminator").HasValue("PermissionSetting");
+                });
+
+            modelBuilder.Entity("Abp.Authorization.Roles.RoleClaim", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<string>("ClaimType")
+                        .HasMaxLength(256);
+
+                    b.Property<string>("ClaimValue");
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<int>("RoleId");
+
+                    b.Property<int?>("TenantId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("RoleId");
+
+                    b.HasIndex("TenantId", "ClaimType");
+
+                    b.ToTable("AbpRoleClaims");
+                });
+
+            modelBuilder.Entity("Abp.Authorization.Users.UserAccount", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<long?>("DeleterUserId");
+
+                    b.Property<DateTime?>("DeletionTime");
+
+                    b.Property<string>("EmailAddress")
+                        .HasMaxLength(256);
+
+                    b.Property<bool>("IsDeleted");
+
+                    b.Property<DateTime?>("LastModificationTime");
+
+                    b.Property<long?>("LastModifierUserId");
+
+                    b.Property<int?>("TenantId");
+
+                    b.Property<long>("UserId");
+
+                    b.Property<long?>("UserLinkId");
+
+                    b.Property<string>("UserName")
+                        .HasMaxLength(256);
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("EmailAddress");
+
+                    b.HasIndex("UserName");
+
+                    b.HasIndex("TenantId", "EmailAddress");
+
+                    b.HasIndex("TenantId", "UserId");
+
+                    b.HasIndex("TenantId", "UserName");
+
+                    b.ToTable("AbpUserAccounts");
+                });
+
+            modelBuilder.Entity("Abp.Authorization.Users.UserClaim", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<string>("ClaimType")
+                        .HasMaxLength(256);
+
+                    b.Property<string>("ClaimValue");
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<int?>("TenantId");
+
+                    b.Property<long>("UserId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("UserId");
+
+                    b.HasIndex("TenantId", "ClaimType");
+
+                    b.ToTable("AbpUserClaims");
+                });
+
+            modelBuilder.Entity("Abp.Authorization.Users.UserLogin", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<string>("LoginProvider")
+                        .IsRequired()
+                        .HasMaxLength(128);
+
+                    b.Property<string>("ProviderKey")
+                        .IsRequired()
+                        .HasMaxLength(256);
+
+                    b.Property<int?>("TenantId");
+
+                    b.Property<long>("UserId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("UserId");
+
+                    b.HasIndex("TenantId", "UserId");
+
+                    b.HasIndex("TenantId", "LoginProvider", "ProviderKey");
+
+                    b.ToTable("AbpUserLogins");
+                });
+
+            modelBuilder.Entity("Abp.Authorization.Users.UserLoginAttempt", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<string>("BrowserInfo")
+                        .HasMaxLength(512);
+
+                    b.Property<string>("ClientIpAddress")
+                        .HasMaxLength(64);
+
+                    b.Property<string>("ClientName")
+                        .HasMaxLength(128);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<byte>("Result");
+
+                    b.Property<string>("TenancyName")
+                        .HasMaxLength(64);
+
+                    b.Property<int?>("TenantId");
+
+                    b.Property<long?>("UserId");
+
+                    b.Property<string>("UserNameOrEmailAddress")
+                        .HasMaxLength(255);
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("UserId", "TenantId");
+
+                    b.HasIndex("TenancyName", "UserNameOrEmailAddress", "Result");
+
+                    b.ToTable("AbpUserLoginAttempts");
+                });
+
+            modelBuilder.Entity("Abp.Authorization.Users.UserOrganizationUnit", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<bool>("IsDeleted");
+
+                    b.Property<long>("OrganizationUnitId");
+
+                    b.Property<int?>("TenantId");
+
+                    b.Property<long>("UserId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("TenantId", "OrganizationUnitId");
+
+                    b.HasIndex("TenantId", "UserId");
+
+                    b.ToTable("AbpUserOrganizationUnits");
+                });
+
+            modelBuilder.Entity("Abp.Authorization.Users.UserRole", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<int>("RoleId");
+
+                    b.Property<int?>("TenantId");
+
+                    b.Property<long>("UserId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("UserId");
+
+                    b.HasIndex("TenantId", "RoleId");
+
+                    b.HasIndex("TenantId", "UserId");
+
+                    b.ToTable("AbpUserRoles");
+                });
+
+            modelBuilder.Entity("Abp.Authorization.Users.UserToken", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<DateTime?>("ExpireDate");
+
+                    b.Property<string>("LoginProvider")
+                        .HasMaxLength(128);
+
+                    b.Property<string>("Name")
+                        .HasMaxLength(128);
+
+                    b.Property<int?>("TenantId");
+
+                    b.Property<long>("UserId");
+
+                    b.Property<string>("Value")
+                        .HasMaxLength(512);
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("UserId");
+
+                    b.HasIndex("TenantId", "UserId");
+
+                    b.ToTable("AbpUserTokens");
+                });
+
+            modelBuilder.Entity("Abp.BackgroundJobs.BackgroundJobInfo", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<bool>("IsAbandoned");
+
+                    b.Property<string>("JobArgs")
+                        .IsRequired()
+                        .HasMaxLength(1048576);
+
+                    b.Property<string>("JobType")
+                        .IsRequired()
+                        .HasMaxLength(512);
+
+                    b.Property<DateTime?>("LastTryTime");
+
+                    b.Property<DateTime>("NextTryTime");
+
+                    b.Property<byte>("Priority");
+
+                    b.Property<short>("TryCount");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("IsAbandoned", "NextTryTime");
+
+                    b.ToTable("AbpBackgroundJobs");
+                });
+
+            modelBuilder.Entity("Abp.Configuration.Setting", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<DateTime?>("LastModificationTime");
+
+                    b.Property<long?>("LastModifierUserId");
+
+                    b.Property<string>("Name")
+                        .IsRequired()
+                        .HasMaxLength(256);
+
+                    b.Property<int?>("TenantId");
+
+                    b.Property<long?>("UserId");
+
+                    b.Property<string>("Value")
+                        .HasMaxLength(2000);
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("UserId");
+
+                    b.HasIndex("TenantId", "Name");
+
+                    b.ToTable("AbpSettings");
+                });
+
+            modelBuilder.Entity("Abp.EntityHistory.EntityChange", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<DateTime>("ChangeTime");
+
+                    b.Property<byte>("ChangeType");
+
+                    b.Property<long>("EntityChangeSetId");
+
+                    b.Property<string>("EntityId")
+                        .HasMaxLength(48);
+
+                    b.Property<string>("EntityTypeFullName")
+                        .HasMaxLength(192);
+
+                    b.Property<int?>("TenantId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("EntityChangeSetId");
+
+                    b.HasIndex("EntityTypeFullName", "EntityId");
+
+                    b.ToTable("AbpEntityChanges");
+                });
+
+            modelBuilder.Entity("Abp.EntityHistory.EntityChangeSet", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<string>("BrowserInfo")
+                        .HasMaxLength(512);
+
+                    b.Property<string>("ClientIpAddress")
+                        .HasMaxLength(64);
+
+                    b.Property<string>("ClientName")
+                        .HasMaxLength(128);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<string>("ExtensionData");
+
+                    b.Property<int?>("ImpersonatorTenantId");
+
+                    b.Property<long?>("ImpersonatorUserId");
+
+                    b.Property<string>("Reason")
+                        .HasMaxLength(256);
+
+                    b.Property<int?>("TenantId");
+
+                    b.Property<long?>("UserId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("TenantId", "CreationTime");
+
+                    b.HasIndex("TenantId", "Reason");
+
+                    b.HasIndex("TenantId", "UserId");
+
+                    b.ToTable("AbpEntityChangeSets");
+                });
+
+            modelBuilder.Entity("Abp.EntityHistory.EntityPropertyChange", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<long>("EntityChangeId");
+
+                    b.Property<string>("NewValue")
+                        .HasMaxLength(512);
+
+                    b.Property<string>("OriginalValue")
+                        .HasMaxLength(512);
+
+                    b.Property<string>("PropertyName")
+                        .HasMaxLength(96);
+
+                    b.Property<string>("PropertyTypeFullName")
+                        .HasMaxLength(192);
+
+                    b.Property<int?>("TenantId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("EntityChangeId");
+
+                    b.ToTable("AbpEntityPropertyChanges");
+                });
+
+            modelBuilder.Entity("Abp.Localization.ApplicationLanguage", b =>
+                {
+                    b.Property<int>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<long?>("DeleterUserId");
+
+                    b.Property<DateTime?>("DeletionTime");
+
+                    b.Property<string>("DisplayName")
+                        .IsRequired()
+                        .HasMaxLength(64);
+
+                    b.Property<string>("Icon")
+                        .HasMaxLength(128);
+
+                    b.Property<bool>("IsDeleted");
+
+                    b.Property<bool>("IsDisabled");
+
+                    b.Property<DateTime?>("LastModificationTime");
+
+                    b.Property<long?>("LastModifierUserId");
+
+                    b.Property<string>("Name")
+                        .IsRequired()
+                        .HasMaxLength(10);
+
+                    b.Property<int?>("TenantId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("TenantId", "Name");
+
+                    b.ToTable("AbpLanguages");
+                });
+
+            modelBuilder.Entity("Abp.Localization.ApplicationLanguageText", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<string>("Key")
+                        .IsRequired()
+                        .HasMaxLength(256);
+
+                    b.Property<string>("LanguageName")
+                        .IsRequired()
+                        .HasMaxLength(10);
+
+                    b.Property<DateTime?>("LastModificationTime");
+
+                    b.Property<long?>("LastModifierUserId");
+
+                    b.Property<string>("Source")
+                        .IsRequired()
+                        .HasMaxLength(128);
+
+                    b.Property<int?>("TenantId");
+
+                    b.Property<string>("Value")
+                        .IsRequired()
+                        .HasMaxLength(67108864);
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("TenantId", "Source", "LanguageName", "Key");
+
+                    b.ToTable("AbpLanguageTexts");
+                });
+
+            modelBuilder.Entity("Abp.Notifications.NotificationInfo", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd();
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<string>("Data")
+                        .HasMaxLength(1048576);
+
+                    b.Property<string>("DataTypeName")
+                        .HasMaxLength(512);
+
+                    b.Property<string>("EntityId")
+                        .HasMaxLength(96);
+
+                    b.Property<string>("EntityTypeAssemblyQualifiedName")
+                        .HasMaxLength(512);
+
+                    b.Property<string>("EntityTypeName")
+                        .HasMaxLength(250);
+
+                    b.Property<string>("ExcludedUserIds")
+                        .HasMaxLength(131072);
+
+                    b.Property<string>("NotificationName")
+                        .IsRequired()
+                        .HasMaxLength(96);
+
+                    b.Property<byte>("Severity");
+
+                    b.Property<string>("TenantIds")
+                        .HasMaxLength(131072);
+
+                    b.Property<string>("UserIds")
+                        .HasMaxLength(131072);
+
+                    b.HasKey("Id");
+
+                    b.ToTable("AbpNotifications");
+                });
+
+            modelBuilder.Entity("Abp.Notifications.NotificationSubscriptionInfo", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd();
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<string>("EntityId")
+                        .HasMaxLength(96);
+
+                    b.Property<string>("EntityTypeAssemblyQualifiedName")
+                        .HasMaxLength(512);
+
+                    b.Property<string>("EntityTypeName")
+                        .HasMaxLength(250);
+
+                    b.Property<string>("NotificationName")
+                        .HasMaxLength(96);
+
+                    b.Property<int?>("TenantId");
+
+                    b.Property<long>("UserId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("NotificationName", "EntityTypeName", "EntityId", "UserId");
+
+                    b.HasIndex("TenantId", "NotificationName", "EntityTypeName", "EntityId", "UserId");
+
+                    b.ToTable("AbpNotificationSubscriptions");
+                });
+
+            modelBuilder.Entity("Abp.Notifications.TenantNotificationInfo", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd();
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<string>("Data")
+                        .HasMaxLength(1048576);
+
+                    b.Property<string>("DataTypeName")
+                        .HasMaxLength(512);
+
+                    b.Property<string>("EntityId")
+                        .HasMaxLength(96);
+
+                    b.Property<string>("EntityTypeAssemblyQualifiedName")
+                        .HasMaxLength(512);
+
+                    b.Property<string>("EntityTypeName")
+                        .HasMaxLength(250);
+
+                    b.Property<string>("NotificationName")
+                        .IsRequired()
+                        .HasMaxLength(96);
+
+                    b.Property<byte>("Severity");
+
+                    b.Property<int?>("TenantId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("TenantId");
+
+                    b.ToTable("AbpTenantNotifications");
+                });
+
+            modelBuilder.Entity("Abp.Notifications.UserNotificationInfo", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd();
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<int>("State");
+
+                    b.Property<int?>("TenantId");
+
+                    b.Property<Guid>("TenantNotificationId");
+
+                    b.Property<long>("UserId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("UserId", "State", "CreationTime");
+
+                    b.ToTable("AbpUserNotifications");
+                });
+
+            modelBuilder.Entity("Abp.Organizations.OrganizationUnit", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<string>("Code")
+                        .IsRequired()
+                        .HasMaxLength(95);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<long?>("DeleterUserId");
+
+                    b.Property<DateTime?>("DeletionTime");
+
+                    b.Property<string>("DisplayName")
+                        .IsRequired()
+                        .HasMaxLength(128);
+
+                    b.Property<bool>("IsDeleted");
+
+                    b.Property<DateTime?>("LastModificationTime");
+
+                    b.Property<long?>("LastModifierUserId");
+
+                    b.Property<long?>("ParentId");
+
+                    b.Property<int?>("TenantId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("ParentId");
+
+                    b.HasIndex("TenantId", "Code");
+
+                    b.ToTable("AbpOrganizationUnits");
+                });
+
+            modelBuilder.Entity("Abp.Organizations.OrganizationUnitRole", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<bool>("IsDeleted");
+
+                    b.Property<long>("OrganizationUnitId");
+
+                    b.Property<int>("RoleId");
+
+                    b.Property<int?>("TenantId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("TenantId", "OrganizationUnitId");
+
+                    b.HasIndex("TenantId", "RoleId");
+
+                    b.ToTable("AbpOrganizationUnitRoles");
+                });
+
+            modelBuilder.Entity("MGS.BoilerplateDemo.Authorization.Roles.Role", b =>
+                {
+                    b.Property<int>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<string>("ConcurrencyStamp")
+                        .IsConcurrencyToken()
+                        .HasMaxLength(128);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<long?>("DeleterUserId");
+
+                    b.Property<DateTime?>("DeletionTime");
+
+                    b.Property<string>("Description")
+                        .HasMaxLength(5000);
+
+                    b.Property<string>("DisplayName")
+                        .IsRequired()
+                        .HasMaxLength(64);
+
+                    b.Property<bool>("IsDefault");
+
+                    b.Property<bool>("IsDeleted");
+
+                    b.Property<bool>("IsStatic");
+
+                    b.Property<DateTime?>("LastModificationTime");
+
+                    b.Property<long?>("LastModifierUserId");
+
+                    b.Property<string>("Name")
+                        .IsRequired()
+                        .HasMaxLength(32);
+
+                    b.Property<string>("NormalizedName")
+                        .IsRequired()
+                        .HasMaxLength(32);
+
+                    b.Property<int?>("TenantId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("CreatorUserId");
+
+                    b.HasIndex("DeleterUserId");
+
+                    b.HasIndex("LastModifierUserId");
+
+                    b.HasIndex("TenantId", "NormalizedName");
+
+                    b.ToTable("AbpRoles");
+                });
+
+            modelBuilder.Entity("MGS.BoilerplateDemo.Authorization.Users.User", b =>
+                {
+                    b.Property<long>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<int>("AccessFailedCount");
+
+                    b.Property<string>("AuthenticationSource")
+                        .HasMaxLength(64);
+
+                    b.Property<string>("ConcurrencyStamp")
+                        .IsConcurrencyToken()
+                        .HasMaxLength(128);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<long?>("DeleterUserId");
+
+                    b.Property<DateTime?>("DeletionTime");
+
+                    b.Property<string>("EmailAddress")
+                        .IsRequired()
+                        .HasMaxLength(256);
+
+                    b.Property<string>("EmailConfirmationCode")
+                        .HasMaxLength(328);
+
+                    b.Property<bool>("IsActive");
+
+                    b.Property<bool>("IsDeleted");
+
+                    b.Property<bool>("IsEmailConfirmed");
+
+                    b.Property<bool>("IsLockoutEnabled");
+
+                    b.Property<bool>("IsPhoneNumberConfirmed");
+
+                    b.Property<bool>("IsTwoFactorEnabled");
+
+                    b.Property<DateTime?>("LastModificationTime");
+
+                    b.Property<long?>("LastModifierUserId");
+
+                    b.Property<DateTime?>("LockoutEndDateUtc");
+
+                    b.Property<string>("Name")
+                        .IsRequired()
+                        .HasMaxLength(64);
+
+                    b.Property<string>("NormalizedEmailAddress")
+                        .IsRequired()
+                        .HasMaxLength(256);
+
+                    b.Property<string>("NormalizedUserName")
+                        .IsRequired()
+                        .HasMaxLength(256);
+
+                    b.Property<string>("Password")
+                        .IsRequired()
+                        .HasMaxLength(128);
+
+                    b.Property<string>("PasswordResetCode")
+                        .HasMaxLength(328);
+
+                    b.Property<string>("PhoneNumber")
+                        .HasMaxLength(32);
+
+                    b.Property<string>("SecurityStamp")
+                        .HasMaxLength(128);
+
+                    b.Property<string>("Surname")
+                        .IsRequired()
+                        .HasMaxLength(64);
+
+                    b.Property<int?>("TenantId");
+
+                    b.Property<string>("UserName")
+                        .IsRequired()
+                        .HasMaxLength(256);
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("CreatorUserId");
+
+                    b.HasIndex("DeleterUserId");
+
+                    b.HasIndex("LastModifierUserId");
+
+                    b.HasIndex("TenantId", "NormalizedEmailAddress");
+
+                    b.HasIndex("TenantId", "NormalizedUserName");
+
+                    b.ToTable("AbpUsers");
+                });
+
+            modelBuilder.Entity("MGS.BoilerplateDemo.BoilerplateDemo.Contacts.Contact", b =>
+                {
+                    b.Property<int>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<long?>("DeleterUserId");
+
+                    b.Property<DateTime?>("DeletionTime");
+
+                    b.Property<string>("Email")
+                        .IsRequired();
+
+                    b.Property<string>("FirstName")
+                        .IsRequired();
+
+                    b.Property<bool>("IsActive");
+
+                    b.Property<bool>("IsDeleted");
+
+                    b.Property<DateTime?>("LastModificationTime");
+
+                    b.Property<long?>("LastModifierUserId");
+
+                    b.Property<string>("LastName")
+                        .IsRequired();
+
+                    b.Property<int>("StateId");
+
+                    b.Property<int>("TenantId");
+
+                    b.Property<int?>("TitleId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("StateId");
+
+                    b.HasIndex("TitleId");
+
+                    b.ToTable("Contacts");
+                });
+
+            modelBuilder.Entity("MGS.BoilerplateDemo.BoilerplateDemo.OptionListsAndListItems.OptionList", b =>
+                {
+                    b.Property<int>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<long?>("DeleterUserId");
+
+                    b.Property<DateTime?>("DeletionTime");
+
+                    b.Property<string>("Description")
+                        .HasMaxLength(256);
+
+                    b.Property<string>("DisplayName")
+                        .IsRequired()
+                        .HasMaxLength(32);
+
+                    b.Property<bool>("IsActive");
+
+                    b.Property<bool>("IsDeleted");
+
+                    b.Property<DateTime?>("LastModificationTime");
+
+                    b.Property<long?>("LastModifierUserId");
+
+                    b.Property<string>("OptionListKey")
+                        .IsRequired()
+                        .HasMaxLength(128);
+
+                    b.Property<int?>("TenantId");
+
+                    b.HasKey("Id");
+
+                    b.ToTable("OptionLists");
+                });
+
+            modelBuilder.Entity("MGS.BoilerplateDemo.BoilerplateDemo.OptionListsAndListItems.OptionListItem", b =>
+                {
+                    b.Property<int>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<string>("AdditionalInfo")
+                        .HasMaxLength(128);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<long?>("DeleterUserId");
+
+                    b.Property<DateTime?>("DeletionTime");
+
+                    b.Property<int>("DisplayOrder");
+
+                    b.Property<string>("DisplayText")
+                        .IsRequired()
+                        .HasMaxLength(32);
+
+                    b.Property<bool>("IsActive");
+
+                    b.Property<bool>("IsDeleted");
+
+                    b.Property<DateTime?>("LastModificationTime");
+
+                    b.Property<long?>("LastModifierUserId");
+
+                    b.Property<int>("OptionListId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("OptionListId");
+
+                    b.ToTable("OptionListItems");
+                });
+
+            modelBuilder.Entity("MGS.BoilerplateDemo.MultiTenancy.Tenant", b =>
+                {
+                    b.Property<int>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<string>("ConnectionString")
+                        .HasMaxLength(1024);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<long?>("DeleterUserId");
+
+                    b.Property<DateTime?>("DeletionTime");
+
+                    b.Property<int?>("EditionId");
+
+                    b.Property<bool>("IsActive");
+
+                    b.Property<bool>("IsDeleted");
+
+                    b.Property<DateTime?>("LastModificationTime");
+
+                    b.Property<long?>("LastModifierUserId");
+
+                    b.Property<string>("Name")
+                        .IsRequired()
+                        .HasMaxLength(128);
+
+                    b.Property<string>("TenancyName")
+                        .IsRequired()
+                        .HasMaxLength(64);
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("CreatorUserId");
+
+                    b.HasIndex("DeleterUserId");
+
+                    b.HasIndex("EditionId");
+
+                    b.HasIndex("LastModifierUserId");
+
+                    b.HasIndex("TenancyName");
+
+                    b.ToTable("AbpTenants");
+                });
+
+            modelBuilder.Entity("Abp.Application.Features.EditionFeatureSetting", b =>
+                {
+                    b.HasBaseType("Abp.Application.Features.FeatureSetting");
+
+                    b.Property<int>("EditionId");
+
+                    b.HasIndex("EditionId", "Name");
+
+                    b.ToTable("AbpFeatures");
+
+                    b.HasDiscriminator().HasValue("EditionFeatureSetting");
+                });
+
+            modelBuilder.Entity("Abp.MultiTenancy.TenantFeatureSetting", b =>
+                {
+                    b.HasBaseType("Abp.Application.Features.FeatureSetting");
+
+                    b.HasIndex("TenantId", "Name");
+
+                    b.ToTable("AbpFeatures");
+
+                    b.HasDiscriminator().HasValue("TenantFeatureSetting");
+                });
+
+            modelBuilder.Entity("Abp.Authorization.Roles.RolePermissionSetting", b =>
+                {
+                    b.HasBaseType("Abp.Authorization.PermissionSetting");
+
+                    b.Property<int>("RoleId");
+
+                    b.HasIndex("RoleId");
+
+                    b.ToTable("AbpPermissions");
+
+                    b.HasDiscriminator().HasValue("RolePermissionSetting");
+                });
+
+            modelBuilder.Entity("Abp.Authorization.Users.UserPermissionSetting", b =>
+                {
+                    b.HasBaseType("Abp.Authorization.PermissionSetting");
+
+                    b.Property<long>("UserId");
+
+                    b.HasIndex("UserId");
+
+                    b.ToTable("AbpPermissions");
+
+                    b.HasDiscriminator().HasValue("UserPermissionSetting");
+                });
+
+            modelBuilder.Entity("Abp.Authorization.Roles.RoleClaim", b =>
+                {
+                    b.HasOne("MGS.BoilerplateDemo.Authorization.Roles.Role")
+                        .WithMany("Claims")
+                        .HasForeignKey("RoleId")
+                        .OnDelete(DeleteBehavior.Cascade);
+                });
+
+            modelBuilder.Entity("Abp.Authorization.Users.UserClaim", b =>
+                {
+                    b.HasOne("MGS.BoilerplateDemo.Authorization.Users.User")
+                        .WithMany("Claims")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade);
+                });
+
+            modelBuilder.Entity("Abp.Authorization.Users.UserLogin", b =>
+                {
+                    b.HasOne("MGS.BoilerplateDemo.Authorization.Users.User")
+                        .WithMany("Logins")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade);
+                });
+
+            modelBuilder.Entity("Abp.Authorization.Users.UserRole", b =>
+                {
+                    b.HasOne("MGS.BoilerplateDemo.Authorization.Users.User")
+                        .WithMany("Roles")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade);
+                });
+
+            modelBuilder.Entity("Abp.Authorization.Users.UserToken", b =>
+                {
+                    b.HasOne("MGS.BoilerplateDemo.Authorization.Users.User")
+                        .WithMany("Tokens")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade);
+                });
+
+            modelBuilder.Entity("Abp.Configuration.Setting", b =>
+                {
+                    b.HasOne("MGS.BoilerplateDemo.Authorization.Users.User")
+                        .WithMany("Settings")
+                        .HasForeignKey("UserId");
+                });
+
+            modelBuilder.Entity("Abp.EntityHistory.EntityChange", b =>
+                {
+                    b.HasOne("Abp.EntityHistory.EntityChangeSet")
+                        .WithMany("EntityChanges")
+                        .HasForeignKey("EntityChangeSetId")
+                        .OnDelete(DeleteBehavior.Cascade);
+                });
+
+            modelBuilder.Entity("Abp.EntityHistory.EntityPropertyChange", b =>
+                {
+                    b.HasOne("Abp.EntityHistory.EntityChange")
+                        .WithMany("PropertyChanges")
+                        .HasForeignKey("EntityChangeId")
+                        .OnDelete(DeleteBehavior.Cascade);
+                });
+
+            modelBuilder.Entity("Abp.Organizations.OrganizationUnit", b =>
+                {
+                    b.HasOne("Abp.Organizations.OrganizationUnit", "Parent")
+                        .WithMany("Children")
+                        .HasForeignKey("ParentId");
+                });
+
+            modelBuilder.Entity("MGS.BoilerplateDemo.Authorization.Roles.Role", b =>
+                {
+                    b.HasOne("MGS.BoilerplateDemo.Authorization.Users.User", "CreatorUser")
+                        .WithMany()
+                        .HasForeignKey("CreatorUserId");
+
+                    b.HasOne("MGS.BoilerplateDemo.Authorization.Users.User", "DeleterUser")
+                        .WithMany()
+                        .HasForeignKey("DeleterUserId");
+
+                    b.HasOne("MGS.BoilerplateDemo.Authorization.Users.User", "LastModifierUser")
+                        .WithMany()
+                        .HasForeignKey("LastModifierUserId");
+                });
+
+            modelBuilder.Entity("MGS.BoilerplateDemo.Authorization.Users.User", b =>
+                {
+                    b.HasOne("MGS.BoilerplateDemo.Authorization.Users.User", "CreatorUser")
+                        .WithMany()
+                        .HasForeignKey("CreatorUserId");
+
+                    b.HasOne("MGS.BoilerplateDemo.Authorization.Users.User", "DeleterUser")
+                        .WithMany()
+                        .HasForeignKey("DeleterUserId");
+
+                    b.HasOne("MGS.BoilerplateDemo.Authorization.Users.User", "LastModifierUser")
+                        .WithMany()
+                        .HasForeignKey("LastModifierUserId");
+                });
+
+            modelBuilder.Entity("MGS.BoilerplateDemo.BoilerplateDemo.Contacts.Contact", b =>
+                {
+                    b.HasOne("MGS.BoilerplateDemo.BoilerplateDemo.OptionListsAndListItems.OptionListItem", "State")
+                        .WithMany()
+                        .HasForeignKey("StateId")
+                        .OnDelete(DeleteBehavior.Cascade);
+
+                    b.HasOne("MGS.BoilerplateDemo.BoilerplateDemo.OptionListsAndListItems.OptionListItem", "Title")
+                        .WithMany()
+                        .HasForeignKey("TitleId");
+                });
+
+            modelBuilder.Entity("MGS.BoilerplateDemo.BoilerplateDemo.OptionListsAndListItems.OptionListItem", b =>
+                {
+                    b.HasOne("MGS.BoilerplateDemo.BoilerplateDemo.OptionListsAndListItems.OptionList", "OptionList")
+                        .WithMany("OptionListItems")
+                        .HasForeignKey("OptionListId")
+                        .OnDelete(DeleteBehavior.Cascade);
+                });
+
+            modelBuilder.Entity("MGS.BoilerplateDemo.MultiTenancy.Tenant", b =>
+                {
+                    b.HasOne("MGS.BoilerplateDemo.Authorization.Users.User", "CreatorUser")
+                        .WithMany()
+                        .HasForeignKey("CreatorUserId");
+
+                    b.HasOne("MGS.BoilerplateDemo.Authorization.Users.User", "DeleterUser")
+                        .WithMany()
+                        .HasForeignKey("DeleterUserId");
+
+                    b.HasOne("Abp.Application.Editions.Edition", "Edition")
+                        .WithMany()
+                        .HasForeignKey("EditionId");
+
+                    b.HasOne("MGS.BoilerplateDemo.Authorization.Users.User", "LastModifierUser")
+                        .WithMany()
+                        .HasForeignKey("LastModifierUserId");
+                });
+
+            modelBuilder.Entity("Abp.Application.Features.EditionFeatureSetting", b =>
+                {
+                    b.HasOne("Abp.Application.Editions.Edition", "Edition")
+                        .WithMany()
+                        .HasForeignKey("EditionId")
+                        .OnDelete(DeleteBehavior.Cascade);
+                });
+
+            modelBuilder.Entity("Abp.Authorization.Roles.RolePermissionSetting", b =>
+                {
+                    b.HasOne("MGS.BoilerplateDemo.Authorization.Roles.Role")
+                        .WithMany("Permissions")
+                        .HasForeignKey("RoleId")
+                        .OnDelete(DeleteBehavior.Cascade);
+                });
+
+            modelBuilder.Entity("Abp.Authorization.Users.UserPermissionSetting", b =>
+                {
+                    b.HasOne("MGS.BoilerplateDemo.Authorization.Users.User")
+                        .WithMany("Permissions")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade);
+                });
+#pragma warning restore 612, 618
+        }
+    }
+}
diff --git a/src/MGS.BoilerplateDemo.EntityFrameworkCore/Migrations/20190519030513_Create Contact Object for Demo.cs b/src/MGS.BoilerplateDemo.EntityFrameworkCore/Migrations/20190519030513_Create Contact Object for Demo.cs
new file mode 100644
index 0000000..c7daa2b
--- /dev/null
+++ b/src/MGS.BoilerplateDemo.EntityFrameworkCore/Migrations/20190519030513_Create Contact Object for Demo.cs	
@@ -0,0 +1,66 @@
+﻿using System;
+using Microsoft.EntityFrameworkCore.Metadata;
+using Microsoft.EntityFrameworkCore.Migrations;
+
+namespace MGS.BoilerplateDemo.Migrations
+{
+    public partial class CreateContactObjectforDemo : Migration
+    {
+        protected override void Up(MigrationBuilder migrationBuilder)
+        {
+            migrationBuilder.CreateTable(
+                name: "Contacts",
+                columns: table => new
+                {
+                    Id = table.Column<int>(nullable: false)
+                        .Annotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn),
+                    CreationTime = table.Column<DateTime>(nullable: false),
+                    CreatorUserId = table.Column<long>(nullable: true),
+                    LastModificationTime = table.Column<DateTime>(nullable: true),
+                    LastModifierUserId = table.Column<long>(nullable: true),
+                    IsDeleted = table.Column<bool>(nullable: false),
+                    DeleterUserId = table.Column<long>(nullable: true),
+                    DeletionTime = table.Column<DateTime>(nullable: true),
+                    TitleId = table.Column<int>(nullable: true),
+                    FirstName = table.Column<string>(nullable: false),
+                    LastName = table.Column<string>(nullable: false),
+                    Email = table.Column<string>(nullable: false),
+                    StateId = table.Column<int>(nullable: false),
+                    TenantId = table.Column<int>(nullable: false),
+                    IsActive = table.Column<bool>(nullable: false)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PK_Contacts", x => x.Id);
+                    table.ForeignKey(
+                        name: "FK_Contacts_OptionListItems_StateId",
+                        column: x => x.StateId,
+                        principalTable: "OptionListItems",
+                        principalColumn: "Id",
+                        onDelete: ReferentialAction.Cascade);
+                    table.ForeignKey(
+                        name: "FK_Contacts_OptionListItems_TitleId",
+                        column: x => x.TitleId,
+                        principalTable: "OptionListItems",
+                        principalColumn: "Id",
+                        onDelete: ReferentialAction.Restrict);
+                });
+
+            migrationBuilder.CreateIndex(
+                name: "IX_Contacts_StateId",
+                table: "Contacts",
+                column: "StateId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_Contacts_TitleId",
+                table: "Contacts",
+                column: "TitleId");
+        }
+
+        protected override void Down(MigrationBuilder migrationBuilder)
+        {
+            migrationBuilder.DropTable(
+                name: "Contacts");
+        }
+    }
+}
diff --git a/src/MGS.BoilerplateDemo.EntityFrameworkCore/Migrations/BoilerplateDemoDbContextModelSnapshot.cs b/src/MGS.BoilerplateDemo.EntityFrameworkCore/Migrations/BoilerplateDemoDbContextModelSnapshot.cs
index 8b97c7e..dccced5 100644
--- a/src/MGS.BoilerplateDemo.EntityFrameworkCore/Migrations/BoilerplateDemoDbContextModelSnapshot.cs
+++ b/src/MGS.BoilerplateDemo.EntityFrameworkCore/Migrations/BoilerplateDemoDbContextModelSnapshot.cs
@@ -1033,6 +1033,52 @@ namespace MGS.BoilerplateDemo.Migrations
                     b.ToTable("AbpUsers");
                 });
 
+            modelBuilder.Entity("MGS.BoilerplateDemo.BoilerplateDemo.Contacts.Contact", b =>
+                {
+                    b.Property<int>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.IdentityColumn);
+
+                    b.Property<DateTime>("CreationTime");
+
+                    b.Property<long?>("CreatorUserId");
+
+                    b.Property<long?>("DeleterUserId");
+
+                    b.Property<DateTime?>("DeletionTime");
+
+                    b.Property<string>("Email")
+                        .IsRequired();
+
+                    b.Property<string>("FirstName")
+                        .IsRequired();
+
+                    b.Property<bool>("IsActive");
+
+                    b.Property<bool>("IsDeleted");
+
+                    b.Property<DateTime?>("LastModificationTime");
+
+                    b.Property<long?>("LastModifierUserId");
+
+                    b.Property<string>("LastName")
+                        .IsRequired();
+
+                    b.Property<int>("StateId");
+
+                    b.Property<int>("TenantId");
+
+                    b.Property<int?>("TitleId");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("StateId");
+
+                    b.HasIndex("TitleId");
+
+                    b.ToTable("Contacts");
+                });
+
             modelBuilder.Entity("MGS.BoilerplateDemo.BoilerplateDemo.OptionListsAndListItems.OptionList", b =>
                 {
                     b.Property<int>("Id")
@@ -1313,6 +1359,18 @@ namespace MGS.BoilerplateDemo.Migrations
                         .HasForeignKey("LastModifierUserId");
                 });
 
+            modelBuilder.Entity("MGS.BoilerplateDemo.BoilerplateDemo.Contacts.Contact", b =>
+                {
+                    b.HasOne("MGS.BoilerplateDemo.BoilerplateDemo.OptionListsAndListItems.OptionListItem", "State")
+                        .WithMany()
+                        .HasForeignKey("StateId")
+                        .OnDelete(DeleteBehavior.Cascade);
+
+                    b.HasOne("MGS.BoilerplateDemo.BoilerplateDemo.OptionListsAndListItems.OptionListItem", "Title")
+                        .WithMany()
+                        .HasForeignKey("TitleId");
+                });
+
             modelBuilder.Entity("MGS.BoilerplateDemo.BoilerplateDemo.OptionListsAndListItems.OptionListItem", b =>
                 {
                     b.HasOne("MGS.BoilerplateDemo.BoilerplateDemo.OptionListsAndListItems.OptionList", "OptionList")
diff --git a/src/MGS.BoilerplateDemo.Web.Host/src/app/app-routing.module.ts b/src/MGS.BoilerplateDemo.Web.Host/src/app/app-routing.module.ts
index efa6773..c33b07e 100644
--- a/src/MGS.BoilerplateDemo.Web.Host/src/app/app-routing.module.ts
+++ b/src/MGS.BoilerplateDemo.Web.Host/src/app/app-routing.module.ts
@@ -11,6 +11,7 @@ import { OptionListItemsComponent } from './optionlistitems/optionlistitems.comp
 import { OptionListsComponent } from './optionlists/optionlists.component';
 import { HostOptionListsComponent } from './host/optionlists/hostoptionlists.component';
 import { HostOptionListItemsComponent } from './host/optionlistitems/optionlistitems.component';
+import { ContactsComponent } from './contacts/contacts.component';
 
 @NgModule({
     imports: [
@@ -28,6 +29,7 @@ import { HostOptionListItemsComponent } from './host/optionlistitems/optionlisti
                     { path: 'optionlistitems', component:OptionListItemsComponent, data: { permission: 'Pages.OptionListItems'}, canActivate: [AppRouteGuard] },
                     { path: 'host/optionlists', component: HostOptionListsComponent, data: { permission: 'Pages.Tenants.OptionLists'}, canActivate: [AppRouteGuard] },
                     { path: 'host/optionlistitems', component: HostOptionListItemsComponent, data: { permission: 'Pages.Tenants.OptionListItems'}, canActivate: [AppRouteGuard] },
+                    { path: 'contacts', component: ContactsComponent, data: { permission: 'Pages.Contacts' }, canActivate: [AppRouteGuard] }
                 ]
             }
         ])
diff --git a/src/MGS.BoilerplateDemo.Web.Host/src/app/app.module.ts b/src/MGS.BoilerplateDemo.Web.Host/src/app/app.module.ts
index ab8e529..09fdcfe 100644
--- a/src/MGS.BoilerplateDemo.Web.Host/src/app/app.module.ts
+++ b/src/MGS.BoilerplateDemo.Web.Host/src/app/app.module.ts
@@ -53,6 +53,9 @@ import { HostEditOptionListDialogComponent } from './host/optionlists/edit/edit-
 import { HostOptionListItemsComponent } from './host/optionlistitems/optionlistitems.component';
 import { HostCreateOptionListItemsDialogComponent } from './host/optionlistitems/create/create-optionlistitems-dialog.component';
 import { HostEditOptionListItemsDialogComponent } from './host/optionlistitems/edit/edit-optionlistitems-dialog.component';
+import { ContactsComponent } from './contacts/contacts.component';
+import { EditContactDialogComponent } from './contacts/edit/edit-contact-dialog.component';
+import { CreateContactDialogComponent } from './contacts/create/create-contact-dialog.component';
 
 @NgModule({
   declarations: [
@@ -94,7 +97,11 @@ import { HostEditOptionListItemsDialogComponent } from './host/optionlistitems/e
     //host option list items
     HostOptionListItemsComponent,
     HostCreateOptionListItemsDialogComponent,
-    HostEditOptionListItemsDialogComponent
+    HostEditOptionListItemsDialogComponent,
+    //contacts
+    ContactsComponent,
+    EditContactDialogComponent,
+    CreateContactDialogComponent
   ],
   imports: [
     CommonModule,
@@ -136,7 +143,11 @@ import { HostEditOptionListItemsDialogComponent } from './host/optionlistitems/e
     //host option list items
     HostOptionListItemsComponent,
     HostCreateOptionListItemsDialogComponent,
-    HostEditOptionListItemsDialogComponent
+    HostEditOptionListItemsDialogComponent,
+    //contacts
+    ContactsComponent,
+    EditContactDialogComponent,
+    CreateContactDialogComponent
   ]
 })
 export class AppModule {}
diff --git a/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/contacts.component.html b/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/contacts.component.html
new file mode 100644
index 0000000..95107a6
--- /dev/null
+++ b/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/contacts.component.html
@@ -0,0 +1,113 @@
+<div class="row clearfix" [@routerTransition]>
+    <div class="col-lg-12 col-md-12 col-sm-12 col-xs-12">
+      <div class="card main-content">
+        <div class="header">
+          <h2>{{ "Contacts" | localize }}</h2>
+          <ul class="header-dropdown m-r--5">
+            <li>
+              <button
+                mat-icon-button
+                [matMenuTriggerFor]="headerMenu"
+                class="header-dropdown-mat-icon-button"
+              >
+                <mat-icon>more_vert</mat-icon>
+              </button>
+              <mat-menu #headerMenu="matMenu">
+                <button mat-menu-item (click)="refresh()">
+                  <mat-icon>refresh</mat-icon>
+                  <span>{{ "Refresh" | localize }}</span>
+                </button>
+              </mat-menu>
+            </li>
+          </ul>
+        </div>
+        <div class="body table-responsive">
+          <table class="table table-hover table-striped" [busy]="isTableLoading">
+            <thead>
+              <tr>
+                <th *ngIf="displayTitles()">{{ "Title" | localize }}</th>
+                <th>{{ "First Name" | localize }}</th>
+                <th>{{ "Last Name" | localize }}</th>
+                <th>{{ "Email" | localize }}</th>
+                <th>{{ "State" | localize }}</th>
+                <th>
+                  <div style="text-align:center">{{ "IsActive" | localize }}</div>
+                </th>
+                <th>{{ "Actions" | localize }}</th>
+              </tr>
+            </thead>
+            <tbody>
+              <tr
+                *ngFor="
+                  let contact of (contacts
+                    | paginate
+                      : {
+                          id: 'server',
+                          itemsPerPage: pageSize,
+                          currentPage: pageNumber,
+                          totalItems: totalItems
+                        })
+                "
+              >
+                <td *ngIf="displayTitles()">{{ contact.titleDisplay }}</td>
+                <td>{{ contact.firstName }}</td>
+                <td>{{ contact.lastName }}</td>
+                <td>{{ contact.email }}</td>
+                <td>{{ contact.stateDisplay }}</td>
+                <td align="center">
+                  <i
+                    class="material-icons"
+                    *ngIf="contact.isActive"
+                    style="color:green;"
+                  >
+                    check_box
+                  </i>
+                  <i
+                    class="material-icons"
+                    *ngIf="!contact.isActive"
+                    style="color:red;"
+                  >
+                    indeterminate_check_box
+                  </i>
+                </td>
+                <td>
+                  <button class="action-button" mat-icon-button [matMenuTriggerFor]="actionsMenu">
+                    <mat-icon>menu</mat-icon>
+                  </button>
+                  <mat-menu #actionsMenu="matMenu">
+                    <button mat-menu-item (click)="editContact(contact)">
+                      <mat-icon>edit</mat-icon>
+                      <span>{{ "Edit" | localize }}</span>
+                    </button>
+                    <button mat-menu-item (click)="delete(contact)">
+                      <mat-icon>delete</mat-icon>
+                      <span>{{ "Delete" | localize }}</span>
+                    </button>
+                  </mat-menu>
+                </td>
+              </tr>
+            </tbody>
+          </table>
+          <div
+            class="abp-pagination-controls-wrapper"
+            *ngIf="totalItems > pageSize"
+          >
+            <abp-pagination-controls
+              (pageChange)="getDataPage($event)"
+              id="server"
+            >
+            </abp-pagination-controls>
+          </div>
+          <button
+            mat-mini-fab
+            color="primary"
+            class="pull-right"
+            (click)="createContact()"
+          >
+            <mat-icon>add</mat-icon>
+          </button>
+        </div>
+      </div>
+    </div>
+  </div>
+  
\ No newline at end of file
diff --git a/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/contacts.component.less b/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/contacts.component.less
new file mode 100644
index 0000000..fc8c206
--- /dev/null
+++ b/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/contacts.component.less
@@ -0,0 +1,6 @@
+mat-form-field {
+    width: 100%;
+}
+mat-checkbox {
+    padding-bottom: 5px;
+}
\ No newline at end of file
diff --git a/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/contacts.component.ts b/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/contacts.component.ts
new file mode 100644
index 0000000..4f32cd1
--- /dev/null
+++ b/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/contacts.component.ts
@@ -0,0 +1,134 @@
+import { Component, Injector, OnInit } from "@angular/core";
+import { ContactServiceProxy, ContactListViewDto, PagedResultDtoOfContactListViewDto, OptionListItemsServiceProxy, PagedResultDtoOfOptionListItemViewDto, OptionListItemViewDto } from "@shared/service-proxies/service-proxies";
+import { appModuleAnimation } from "@shared/animations/routerTransition";
+import { PagedListingComponentBase, PagedRequestDto } from "@shared/paged-listing-component-base";
+import { MatDialog } from "@angular/material";
+import { finalize } from "rxjs/operators";
+import { CreateContactDialogComponent } from "./create/create-contact-dialog.component";
+import { EditContactDialogComponent } from "./edit/edit-contact-dialog.component";
+
+class PagedContactRequestDto extends PagedRequestDto {
+    key: string;
+    filter: string;
+    sorting: string;
+}
+
+@Component({
+    templateUrl: './contacts.component.html',
+    animations: [appModuleAnimation()],
+    styleUrls: ['./contacts.component.less']
+})
+export class ContactsComponent extends PagedListingComponentBase<ContactListViewDto> implements OnInit {
+    contacts: ContactListViewDto[] = [];
+    states: OptionListItemViewDto[] = [];
+    titles: OptionListItemViewDto[] = [];
+
+    constructor(
+        injector: Injector,
+        private _contactService: ContactServiceProxy,
+        private _optionListItemService: OptionListItemsServiceProxy,
+        private _dialog: MatDialog
+    ) {
+        super(injector);
+    }
+
+    ngOnInit(): void {
+        this.loadStates();
+        this.loadTitles();
+        this.refresh();
+    }
+
+    loadStates(): void {
+        this._optionListItemService.getListItemsByListKey("", "States", "", 0, 1000)
+            .pipe( finalize(() =>{}))
+            .subscribe((result: PagedResultDtoOfOptionListItemViewDto) => {
+                this.states = result.items;
+            });
+    }
+
+    loadTitles(): void {
+        this._optionListItemService.getListItemsByListKey("", "Titles", "", 0, 1000)
+            .pipe( finalize(() =>{}))
+            .subscribe((result: PagedResultDtoOfOptionListItemViewDto) => {
+                this.titles = result.items;
+            });
+    }
+
+    displayTitles(): boolean {
+        return this.titles && this.titles.length > 0;
+    }
+
+    list(request: PagedContactRequestDto, pageNumber: number, finishedCallback: Function): void {
+        console.log("listing");
+        this._contactService
+            .getAll(request.filter, request.key, request.sorting, 0, 1000)
+            .pipe(
+                finalize(() => {
+                    this.contacts.forEach((contact) => {
+                        if (contact.titleId && contact.titleId > 0) {
+                            this.titles.forEach((title) => {
+                                if (title.id == contact.titleId) {
+                                    contact.titleDisplay = title.displayText;
+                                }
+                            });
+                        }
+
+                        this.states.forEach((state) => {
+                            if (state.id == contact.stateId)
+                            {
+                                contact.stateDisplay = state.displayText;
+                                
+                            }
+                        });
+                        console.log(contact);
+                    });
+                    
+                    finishedCallback();
+                })
+            )
+            .subscribe((result: PagedResultDtoOfContactListViewDto) => {
+                this.contacts = result.items;
+                console.log(this.contacts);
+                this.showPaging(result, pageNumber);
+            });
+    }
+
+    protected delete(contact: ContactListViewDto): void {
+        abp.message.confirm(
+            this.l('AreYouSureWantToDelete', contact.firstName + ' ' + contact.lastName),
+            (result: boolean) => {
+                if (result) {
+                    this._contactService.delete(contact.id).subscribe(() => {
+                        abp.notify.success(this.l('SuccessfullyDeleted'));
+                        this.refresh();
+                    });
+                }
+            }
+        );
+    }
+
+    createContact(): void {
+        this.showCreateOrEditContactListDialog();
+    }
+
+    editContact(contact: ContactListViewDto): void {
+        this.showCreateOrEditContactListDialog(contact.id);
+    }
+
+    showCreateOrEditContactListDialog(id?: number): void {
+        let createOrEditContactDialog;
+        if (id === undefined || id <= 0) {
+            createOrEditContactDialog = this._dialog.open(CreateContactDialogComponent);
+        } else {
+            createOrEditContactDialog = this._dialog.open(EditContactDialogComponent, {
+                data: id
+            });
+        }
+
+        createOrEditContactDialog.afterClosed().subscribe(result => {
+            if (result) {
+                this.refresh();
+            }
+        });
+    }
+}
\ No newline at end of file
diff --git a/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/create/create-contact-dialog.component.html b/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/create/create-contact-dialog.component.html
new file mode 100644
index 0000000..47d5cde
--- /dev/null
+++ b/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/create/create-contact-dialog.component.html
@@ -0,0 +1,62 @@
+<form autocomplete="off" #createContactForm="ngForm" (ngSubmit)="save()">
+        <h1 mat-dialog-title>{{ "ContactsCreate" | localize }}</h1>
+      <mat-dialog-content>
+        <div class="row-fluid">
+          <div class="col-md-12">
+            <mat-form-field *ngIf="displayTitles()" >
+                <mat-select name="Title" [(ngModel)]="contact.titleId" placeholder="Title">
+                    <mat-option *ngFor="let title of titles" [value]="title.id">{{ title.displayText }}</mat-option>
+                </mat-select>
+            </mat-form-field>
+            <mat-form-field>
+                <input
+                    matInput
+                    name="FirstName"
+                    [placeholder]="'First Name' | localize"
+                    [(ngModel)]="contact.firstName"
+                />
+            </mat-form-field>
+            <mat-form-field>
+                <input
+                    matInput
+                    name="LastName"
+                    [placeholder]="'Last Name' | localize"
+                    [(ngModel)]="contact.lastName"
+                />
+            </mat-form-field>
+            <mat-form-field>
+                <input
+                    matInput
+                    name="Email"
+                    [placeholder]="'Email' | localize"
+                    [(ngModel)]="contact.email"
+                />
+            </mat-form-field>
+            <mat-form-field>
+                <mat-select name="State" [(ngModel)]="contact.stateId" placeholder="State" required>
+                    <mat-option *ngFor="let state of states" [value]="state.id">{{ state.displayText }}</mat-option>
+                </mat-select>
+            </mat-form-field>
+            <div class="checkbox-wrapper">
+              <mat-checkbox name="IsActive" [(ngModel)]="contact.isActive">
+                {{ "IsActive" | localize }}
+              </mat-checkbox>
+            </div>
+          </div>
+        </div>
+      </mat-dialog-content>
+      <div mat-dialog-actions align="end">
+        <button mat-button type="button" [disabled]="saving" (click)="close()">
+          {{ "Cancel" | localize }}
+        </button>
+        <button
+          mat-flat-button
+          type="submit"
+          flex="15"
+          color="primary"
+          [disabled]="!createContactForm.form.valid || saving"
+        >
+          {{ "Save" | localize }}
+        </button>
+      </div>
+    </form>
\ No newline at end of file
diff --git a/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/create/create-contact-dialog.component.less b/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/create/create-contact-dialog.component.less
new file mode 100644
index 0000000..fc8c206
--- /dev/null
+++ b/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/create/create-contact-dialog.component.less
@@ -0,0 +1,6 @@
+mat-form-field {
+    width: 100%;
+}
+mat-checkbox {
+    padding-bottom: 5px;
+}
\ No newline at end of file
diff --git a/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/create/create-contact-dialog.component.ts b/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/create/create-contact-dialog.component.ts
new file mode 100644
index 0000000..e46eb5a
--- /dev/null
+++ b/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/create/create-contact-dialog.component.ts
@@ -0,0 +1,74 @@
+import { Component, OnInit, Injector } from "@angular/core";
+import { AppComponentBase } from "@shared/app-component-base";
+import { MatDialogRef } from "@angular/material";
+import { ContactListViewDto, ContactServiceProxy, OptionListViewDto, OptionListItemsServiceProxy, PagedResultDtoOfOptionListItemViewDto, OptionListItemViewDto } from "@shared/service-proxies/service-proxies";
+import { finalize } from "rxjs/operators";
+
+@Component({
+templateUrl: './create-contact-dialog.component.html',
+styleUrls: ['./create-contact-dialog.component.less']
+})
+export class CreateContactDialogComponent extends AppComponentBase implements OnInit {
+    saving = false;
+    contact: ContactListViewDto = new ContactListViewDto();
+    titles: OptionListItemViewDto[] = [];
+    states: OptionListItemViewDto[] = [];
+    
+    constructor(injector: Injector,
+                private _optionListItemService: OptionListItemsServiceProxy,
+                private _contactService: ContactServiceProxy,
+                private _dialogRef: MatDialogRef<CreateContactDialogComponent>) 
+    {
+        super(injector);
+    }
+
+    ngOnInit(): void {
+        this.loadStates();
+        this.loadTitles();
+        this.contact.isActive = true;
+    }
+
+    loadStates(): void {
+        this._optionListItemService.getListItemsByListKey("", "States", "", 0, 1000)
+            .pipe( finalize(() =>{}))
+            .subscribe((result: PagedResultDtoOfOptionListItemViewDto) => {
+                console.log("States");
+                console.log(result.items);
+                this.states = result.items;
+            });
+    }
+
+    loadTitles(): void {
+        this._optionListItemService.getListItemsByListKey("", "Titles", "", 0, 1000)
+            .pipe( finalize(() =>{}))
+            .subscribe((result: PagedResultDtoOfOptionListItemViewDto) => {
+                console.log("Titles");
+                console.log(result.items);
+                this.titles = result.items;
+            });
+    }
+
+    displayTitles(): boolean {
+        return this.titles && this.titles.length > 0;
+    }
+
+    save(): void {
+        this.saving = true;
+
+        this._contactService.create(this.contact)
+            .pipe(
+                finalize(() => {
+                this.saving = false;
+                })
+            )
+            .subscribe(() => {
+                this.notify.info(this.l('SavedSuccessfully'));
+                this.close(true);
+        });
+    }
+
+    close(result: any): void {
+        this._dialogRef.close(result);
+    }
+}
+  
\ No newline at end of file
diff --git a/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/edit/edit-contact-dialog.component.html b/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/edit/edit-contact-dialog.component.html
new file mode 100644
index 0000000..d643982
--- /dev/null
+++ b/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/edit/edit-contact-dialog.component.html
@@ -0,0 +1,62 @@
+<form autocomplete="off" #editContactForm="ngForm" (ngSubmit)="save()">
+    <h1 mat-dialog-title>{{ "ContactsCreate" | localize }}</h1>
+  <mat-dialog-content>
+    <div class="row-fluid">
+      <div class="col-md-12">
+        <mat-form-field *ngIf="displayTitles()" >
+            <mat-select name="Title" [(ngModel)]="contact.titleId" placeholder="Title">
+                <mat-option *ngFor="let title of titles" [value]="title.id">{{ title.displayText }}</mat-option>
+            </mat-select>
+        </mat-form-field>
+        <mat-form-field>
+            <input
+                matInput
+                name="FirstName"
+                [placeholder]="'First Name' | localize"
+                [(ngModel)]="contact.firstName"
+            />
+        </mat-form-field>
+        <mat-form-field>
+            <input
+                matInput
+                name="LastName"
+                [placeholder]="'Last Name' | localize"
+                [(ngModel)]="contact.lastName"
+            />
+        </mat-form-field>
+        <mat-form-field>
+            <input
+                matInput
+                name="Email"
+                [placeholder]="'Email' | localize"
+                [(ngModel)]="contact.email"
+            />
+        </mat-form-field>
+        <mat-form-field>
+            <mat-select name="State" [(ngModel)]="contact.stateId" placeholder="State" required>
+                <mat-option *ngFor="let state of states" [value]="state.id">{{ state.displayText }}</mat-option>
+            </mat-select>
+        </mat-form-field>
+        <div class="checkbox-wrapper">
+          <mat-checkbox name="IsActive" [(ngModel)]="contact.isActive">
+            {{ "IsActive" | localize }}
+          </mat-checkbox>
+        </div>
+      </div>
+    </div>
+  </mat-dialog-content>
+  <div mat-dialog-actions align="end">
+    <button mat-button type="button" [disabled]="saving" (click)="close()">
+      {{ "Cancel" | localize }}
+    </button>
+    <button
+      mat-flat-button
+      type="submit"
+      flex="15"
+      color="primary"
+      [disabled]="!editContactForm.form.valid || saving"
+    >
+      {{ "Save" | localize }}
+    </button>
+  </div>
+</form>
\ No newline at end of file
diff --git a/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/edit/edit-contact-dialog.component.less b/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/edit/edit-contact-dialog.component.less
new file mode 100644
index 0000000..fc8c206
--- /dev/null
+++ b/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/edit/edit-contact-dialog.component.less
@@ -0,0 +1,6 @@
+mat-form-field {
+    width: 100%;
+}
+mat-checkbox {
+    padding-bottom: 5px;
+}
\ No newline at end of file
diff --git a/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/edit/edit-contact-dialog.component.ts b/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/edit/edit-contact-dialog.component.ts
new file mode 100644
index 0000000..adce1d1
--- /dev/null
+++ b/src/MGS.BoilerplateDemo.Web.Host/src/app/contacts/edit/edit-contact-dialog.component.ts
@@ -0,0 +1,81 @@
+import { AppComponentBase } from "@shared/app-component-base";
+import { OnInit, Component, Injector, Inject, Optional } from "@angular/core";
+import { MatDialogRef, MAT_DIALOG_DATA } from "@angular/material";
+import { Title } from "@angular/platform-browser";
+import { ContactServiceProxy, ContactListViewDto, OptionListItemsServiceProxy, OptionListItemViewDto, PagedResultDtoOfOptionListItemViewDto } from "@shared/service-proxies/service-proxies";
+import { finalize } from "rxjs/operators";
+
+@Component({
+    templateUrl: './edit-contact-dialog.component.html',
+    styleUrls: ['./edit-contact-dialog.component.less']
+})
+export class EditContactDialogComponent extends AppComponentBase implements OnInit {
+    saving = false;
+    contact: ContactListViewDto = new ContactListViewDto();
+    titles: OptionListItemViewDto[] = [];
+    states: OptionListItemViewDto[] = [];
+   
+    constructor(injector: Injector,
+                    private _dialogRef: MatDialogRef<EditContactDialogComponent>,
+                    private _contactService: ContactServiceProxy,
+                    private _optionListItemService: OptionListItemsServiceProxy,
+                    @Optional() @Inject(MAT_DIALOG_DATA) private _id: number,
+                    private titleService: Title) 
+    {
+      super(injector);
+    }
+  
+    ngOnInit(): void {
+        this.loadStates();
+    }
+
+    loadStates(): void {
+        this._optionListItemService.getListItemsByListKey("", "States", "", 0, 1000)
+            .pipe( finalize(() =>{ this.loadTitles(); }))
+            .subscribe((result: PagedResultDtoOfOptionListItemViewDto) => {
+                console.log("States");
+                console.log(result.items);
+                this.states = result.items;
+            });
+    }
+
+    loadTitles(): void {
+        this._optionListItemService.getListItemsByListKey("", "Titles", "", 0, 1000)
+            .pipe( finalize(() =>{this.loadContact();}))
+            .subscribe((result: PagedResultDtoOfOptionListItemViewDto) => {
+                console.log("Titles");
+                console.log(result.items);
+                this.titles = result.items;
+            });
+    }
+
+    loadContact(): void {
+        this._contactService.get(this._id).subscribe((result: ContactListViewDto) => {
+            this.contact = result;
+            this.titleService.setTitle(this.contact.displayName);
+        });
+    }
+
+    displayTitles(): boolean {
+        return this.titles && this.titles.length > 0;
+    }
+  
+    save(): void {
+        this.saving = true;
+  
+        this._contactService.update(this.contact)
+            .pipe(
+                finalize(() => {
+                    this.saving = false;
+                })
+            )
+            .subscribe(() => {
+                this.notify.info(this.l('SavedSuccessfully'));
+                this.close(true);
+        });
+    }
+  
+    close(result: any): void {
+        this._dialogRef.close(result);
+    }
+}
\ No newline at end of file
diff --git a/src/MGS.BoilerplateDemo.Web.Host/src/app/layout/sidebar-nav.component.ts b/src/MGS.BoilerplateDemo.Web.Host/src/app/layout/sidebar-nav.component.ts
index a7ddfc7..3ef34ce 100644
--- a/src/MGS.BoilerplateDemo.Web.Host/src/app/layout/sidebar-nav.component.ts
+++ b/src/MGS.BoilerplateDemo.Web.Host/src/app/layout/sidebar-nav.component.ts
@@ -29,6 +29,7 @@ export class SideBarNavComponent extends AppComponentBase {
         ]),
 
         //Further menus can be added here as desired..
+        new MenuItem(this.l('ContactsMenu'), 'Pages.Contacts', 'people', '/app/contacts')
     ];
 
     constructor(
diff --git a/src/MGS.BoilerplateDemo.Web.Host/src/shared/service-proxies/service-proxies.ts b/src/MGS.BoilerplateDemo.Web.Host/src/shared/service-proxies/service-proxies.ts
index 0ab397c..7e2db57 100644
--- a/src/MGS.BoilerplateDemo.Web.Host/src/shared/service-proxies/service-proxies.ts
+++ b/src/MGS.BoilerplateDemo.Web.Host/src/shared/service-proxies/service-proxies.ts
@@ -204,7 +204,7 @@ export class ConfigurationServiceProxy {
 }
 
 @Injectable()
-export class OptionListServiceProxy {
+export class ContactServiceProxy {
     private http: HttpClient;
     private baseUrl: string;
     protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
@@ -215,50 +215,40 @@ export class OptionListServiceProxy {
     }
 
     /**
-     * @param filter (optional) 
-     * @param key (optional) 
-     * @param sorting (optional) 
-     * @param skipCount (optional) 
-     * @param maxResultCount (optional) 
+     * @param input (optional) 
      * @return Success
      */
-    getAllLists(filter: string | null | undefined, key: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfOptionListViewDto> {
-        let url_ = this.baseUrl + "/api/services/app/OptionList/GetAllLists?";
-        if (filter !== undefined)
-            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
-        if (key !== undefined)
-            url_ += "Key=" + encodeURIComponent("" + key) + "&"; 
-        if (sorting !== undefined)
-            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
-        if (skipCount !== undefined)
-            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
-        if (maxResultCount !== undefined)
-            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
+    create(input: ContactCreateOrEditDto | null | undefined): Observable<ContactListViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/Contact/Create";
         url_ = url_.replace(/[?&]$/, "");
 
+        const content_ = JSON.stringify(input);
+
         let options_ : any = {
+            body: content_,
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
+                "Content-Type": "application/json", 
                 "Accept": "application/json"
             })
         };
 
-        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetAllLists(response_);
+        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processCreate(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetAllLists(<any>response_);
+                    return this.processCreate(<any>response_);
                 } catch (e) {
-                    return <Observable<PagedResultDtoOfOptionListViewDto>><any>_observableThrow(e);
+                    return <Observable<ContactListViewDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<PagedResultDtoOfOptionListViewDto>><any>_observableThrow(response_);
+                return <Observable<ContactListViewDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGetAllLists(response: HttpResponseBase): Observable<PagedResultDtoOfOptionListViewDto> {
+    protected processCreate(response: HttpResponseBase): Observable<ContactListViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -269,7 +259,7 @@ export class OptionListServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? PagedResultDtoOfOptionListViewDto.fromJS(resultData200) : new PagedResultDtoOfOptionListViewDto();
+            result200 = resultData200 ? ContactListViewDto.fromJS(resultData200) : new ContactListViewDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -277,15 +267,15 @@ export class OptionListServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<PagedResultDtoOfOptionListViewDto>(<any>null);
+        return _observableOf<ContactListViewDto>(<any>null);
     }
 
     /**
      * @param id (optional) 
      * @return Success
      */
-    getListByEntityId(id: number | null | undefined): Observable<OptionListViewDto> {
-        let url_ = this.baseUrl + "/api/services/app/OptionList/GetListByEntityId?";
+    delete(id: number | null | undefined): Observable<void> {
+        let url_ = this.baseUrl + "/api/services/app/Contact/Delete?";
         if (id !== undefined)
             url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
@@ -294,25 +284,24 @@ export class OptionListServiceProxy {
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
-                "Accept": "application/json"
             })
         };
 
-        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetListByEntityId(response_);
+        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processDelete(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetListByEntityId(<any>response_);
+                    return this.processDelete(<any>response_);
                 } catch (e) {
-                    return <Observable<OptionListViewDto>><any>_observableThrow(e);
+                    return <Observable<void>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<OptionListViewDto>><any>_observableThrow(response_);
+                return <Observable<void>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGetListByEntityId(response: HttpResponseBase): Observable<OptionListViewDto> {
+    protected processDelete(response: HttpResponseBase): Observable<void> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -321,27 +310,24 @@ export class OptionListServiceProxy {
         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            let result200: any = null;
-            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? OptionListViewDto.fromJS(resultData200) : new OptionListViewDto();
-            return _observableOf(result200);
+            return _observableOf<void>(<any>null);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<OptionListViewDto>(<any>null);
+        return _observableOf<void>(<any>null);
     }
 
     /**
      * @param id (optional) 
      * @return Success
      */
-    getListById(id: number | null | undefined): Observable<OptionListViewDto> {
-        let url_ = this.baseUrl + "/api/services/app/OptionList/GetListById?";
+    get(id: number | null | undefined): Observable<ContactListViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/Contact/Get?";
         if (id !== undefined)
-            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
+            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
         let options_ : any = {
@@ -353,20 +339,20 @@ export class OptionListServiceProxy {
         };
 
         return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetListById(response_);
+            return this.processGet(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetListById(<any>response_);
+                    return this.processGet(<any>response_);
                 } catch (e) {
-                    return <Observable<OptionListViewDto>><any>_observableThrow(e);
+                    return <Observable<ContactListViewDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<OptionListViewDto>><any>_observableThrow(response_);
+                return <Observable<ContactListViewDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGetListById(response: HttpResponseBase): Observable<OptionListViewDto> {
+    protected processGet(response: HttpResponseBase): Observable<ContactListViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -377,7 +363,7 @@ export class OptionListServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? OptionListViewDto.fromJS(resultData200) : new OptionListViewDto();
+            result200 = resultData200 ? ContactListViewDto.fromJS(resultData200) : new ContactListViewDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -385,7 +371,7 @@ export class OptionListServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<OptionListViewDto>(<any>null);
+        return _observableOf<ContactListViewDto>(<any>null);
     }
 
     /**
@@ -396,8 +382,8 @@ export class OptionListServiceProxy {
      * @param maxResultCount (optional) 
      * @return Success
      */
-    getListByKey(filter: string | null | undefined, key: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<OptionListViewDto> {
-        let url_ = this.baseUrl + "/api/services/app/OptionList/GetListByKey?";
+    getAll(filter: string | null | undefined, key: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfContactListViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/Contact/GetAll?";
         if (filter !== undefined)
             url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
         if (key !== undefined)
@@ -419,20 +405,20 @@ export class OptionListServiceProxy {
         };
 
         return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetListByKey(response_);
+            return this.processGetAll(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetListByKey(<any>response_);
+                    return this.processGetAll(<any>response_);
                 } catch (e) {
-                    return <Observable<OptionListViewDto>><any>_observableThrow(e);
+                    return <Observable<PagedResultDtoOfContactListViewDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<OptionListViewDto>><any>_observableThrow(response_);
+                return <Observable<PagedResultDtoOfContactListViewDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGetListByKey(response: HttpResponseBase): Observable<OptionListViewDto> {
+    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfContactListViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -443,7 +429,7 @@ export class OptionListServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? OptionListViewDto.fromJS(resultData200) : new OptionListViewDto();
+            result200 = resultData200 ? PagedResultDtoOfContactListViewDto.fromJS(resultData200) : new PagedResultDtoOfContactListViewDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -451,15 +437,15 @@ export class OptionListServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<OptionListViewDto>(<any>null);
+        return _observableOf<PagedResultDtoOfContactListViewDto>(<any>null);
     }
 
     /**
      * @param input (optional) 
      * @return Success
      */
-    createOrUpdateList(input: OptionListCreateOrEditDto | null | undefined): Observable<void> {
-        let url_ = this.baseUrl + "/api/services/app/OptionList/CreateOrUpdateList";
+    update(input: ContactCreateOrEditDto | null | undefined): Observable<ContactListViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/Contact/Update";
         url_ = url_.replace(/[?&]$/, "");
 
         const content_ = JSON.stringify(input);
@@ -470,24 +456,25 @@ export class OptionListServiceProxy {
             responseType: "blob",
             headers: new HttpHeaders({
                 "Content-Type": "application/json", 
+                "Accept": "application/json"
             })
         };
 
-        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processCreateOrUpdateList(response_);
+        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processUpdate(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processCreateOrUpdateList(<any>response_);
+                    return this.processUpdate(<any>response_);
                 } catch (e) {
-                    return <Observable<void>><any>_observableThrow(e);
+                    return <Observable<ContactListViewDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<void>><any>_observableThrow(response_);
+                return <Observable<ContactListViewDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processCreateOrUpdateList(response: HttpResponseBase): Observable<void> {
+    protected processUpdate(response: HttpResponseBase): Observable<ContactListViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -496,98 +483,76 @@ export class OptionListServiceProxy {
         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            return _observableOf<void>(<any>null);
+            let result200: any = null;
+            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
+            result200 = resultData200 ? ContactListViewDto.fromJS(resultData200) : new ContactListViewDto();
+            return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<void>(<any>null);
-    }
-
-    /**
-     * @param id (optional) 
-     * @return Success
-     */
-    deleteListByEntity(id: number | null | undefined): Observable<void> {
-        let url_ = this.baseUrl + "/api/services/app/OptionList/DeleteListByEntity?";
-        if (id !== undefined)
-            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
-        url_ = url_.replace(/[?&]$/, "");
-
-        let options_ : any = {
-            observe: "response",
-            responseType: "blob",
-            headers: new HttpHeaders({
-            })
-        };
-
-        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processDeleteListByEntity(response_);
-        })).pipe(_observableCatch((response_: any) => {
-            if (response_ instanceof HttpResponseBase) {
-                try {
-                    return this.processDeleteListByEntity(<any>response_);
-                } catch (e) {
-                    return <Observable<void>><any>_observableThrow(e);
-                }
-            } else
-                return <Observable<void>><any>_observableThrow(response_);
-        }));
+        return _observableOf<ContactListViewDto>(<any>null);
     }
+}
 
-    protected processDeleteListByEntity(response: HttpResponseBase): Observable<void> {
-        const status = response.status;
-        const responseBlob = 
-            response instanceof HttpResponse ? response.body : 
-            (<any>response).error instanceof Blob ? (<any>response).error : undefined;
+@Injectable()
+export class OptionListServiceProxy {
+    private http: HttpClient;
+    private baseUrl: string;
+    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
 
-        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
-        if (status === 200) {
-            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            return _observableOf<void>(<any>null);
-            }));
-        } else if (status !== 200 && status !== 204) {
-            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
-            }));
-        }
-        return _observableOf<void>(<any>null);
+    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
+        this.http = http;
+        this.baseUrl = baseUrl ? baseUrl : "";
     }
 
     /**
-     * @param id (optional) 
+     * @param filter (optional) 
+     * @param key (optional) 
+     * @param sorting (optional) 
+     * @param skipCount (optional) 
+     * @param maxResultCount (optional) 
      * @return Success
      */
-    deleteList(id: number | null | undefined): Observable<void> {
-        let url_ = this.baseUrl + "/api/services/app/OptionList/DeleteList?";
-        if (id !== undefined)
-            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
+    getAllLists(filter: string | null | undefined, key: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfOptionListViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/OptionList/GetAllLists?";
+        if (filter !== undefined)
+            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
+        if (key !== undefined)
+            url_ += "Key=" + encodeURIComponent("" + key) + "&"; 
+        if (sorting !== undefined)
+            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
+        if (skipCount !== undefined)
+            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
+        if (maxResultCount !== undefined)
+            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
         let options_ : any = {
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
+                "Accept": "application/json"
             })
         };
 
-        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processDeleteList(response_);
+        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processGetAllLists(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processDeleteList(<any>response_);
+                    return this.processGetAllLists(<any>response_);
                 } catch (e) {
-                    return <Observable<void>><any>_observableThrow(e);
+                    return <Observable<PagedResultDtoOfOptionListViewDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<void>><any>_observableThrow(response_);
+                return <Observable<PagedResultDtoOfOptionListViewDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processDeleteList(response: HttpResponseBase): Observable<void> {
+    protected processGetAllLists(response: HttpResponseBase): Observable<PagedResultDtoOfOptionListViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -596,48 +561,52 @@ export class OptionListServiceProxy {
         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            return _observableOf<void>(<any>null);
+            let result200: any = null;
+            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
+            result200 = resultData200 ? PagedResultDtoOfOptionListViewDto.fromJS(resultData200) : new PagedResultDtoOfOptionListViewDto();
+            return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<void>(<any>null);
+        return _observableOf<PagedResultDtoOfOptionListViewDto>(<any>null);
     }
 
     /**
-     * @param key (optional) 
+     * @param id (optional) 
      * @return Success
      */
-    deleteListItemsByList(key: string | null | undefined): Observable<void> {
-        let url_ = this.baseUrl + "/api/services/app/OptionList/DeleteListItemsByList?";
-        if (key !== undefined)
-            url_ += "key=" + encodeURIComponent("" + key) + "&"; 
+    getListByEntityId(id: number | null | undefined): Observable<OptionListViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/OptionList/GetListByEntityId?";
+        if (id !== undefined)
+            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
         let options_ : any = {
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
+                "Accept": "application/json"
             })
         };
 
-        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processDeleteListItemsByList(response_);
+        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processGetListByEntityId(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processDeleteListItemsByList(<any>response_);
+                    return this.processGetListByEntityId(<any>response_);
                 } catch (e) {
-                    return <Observable<void>><any>_observableThrow(e);
+                    return <Observable<OptionListViewDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<void>><any>_observableThrow(response_);
+                return <Observable<OptionListViewDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processDeleteListItemsByList(response: HttpResponseBase): Observable<void> {
+    protected processGetListByEntityId(response: HttpResponseBase): Observable<OptionListViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -646,24 +615,27 @@ export class OptionListServiceProxy {
         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            return _observableOf<void>(<any>null);
+            let result200: any = null;
+            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
+            result200 = resultData200 ? OptionListViewDto.fromJS(resultData200) : new OptionListViewDto();
+            return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<void>(<any>null);
+        return _observableOf<OptionListViewDto>(<any>null);
     }
 
     /**
      * @param id (optional) 
      * @return Success
      */
-    get(id: number | null | undefined): Observable<OptionListViewDto> {
-        let url_ = this.baseUrl + "/api/services/app/OptionList/Get?";
+    getListById(id: number | null | undefined): Observable<OptionListViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/OptionList/GetListById?";
         if (id !== undefined)
-            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
+            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
         let options_ : any = {
@@ -675,11 +647,11 @@ export class OptionListServiceProxy {
         };
 
         return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGet(response_);
+            return this.processGetListById(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGet(<any>response_);
+                    return this.processGetListById(<any>response_);
                 } catch (e) {
                     return <Observable<OptionListViewDto>><any>_observableThrow(e);
                 }
@@ -688,7 +660,7 @@ export class OptionListServiceProxy {
         }));
     }
 
-    protected processGet(response: HttpResponseBase): Observable<OptionListViewDto> {
+    protected processGetListById(response: HttpResponseBase): Observable<OptionListViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -718,8 +690,8 @@ export class OptionListServiceProxy {
      * @param maxResultCount (optional) 
      * @return Success
      */
-    getAll(filter: string | null | undefined, key: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfOptionListViewDto> {
-        let url_ = this.baseUrl + "/api/services/app/OptionList/GetAll?";
+    getListByKey(filter: string | null | undefined, key: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<OptionListViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/OptionList/GetListByKey?";
         if (filter !== undefined)
             url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
         if (key !== undefined)
@@ -741,20 +713,20 @@ export class OptionListServiceProxy {
         };
 
         return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetAll(response_);
+            return this.processGetListByKey(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetAll(<any>response_);
+                    return this.processGetListByKey(<any>response_);
                 } catch (e) {
-                    return <Observable<PagedResultDtoOfOptionListViewDto>><any>_observableThrow(e);
+                    return <Observable<OptionListViewDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<PagedResultDtoOfOptionListViewDto>><any>_observableThrow(response_);
+                return <Observable<OptionListViewDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfOptionListViewDto> {
+    protected processGetListByKey(response: HttpResponseBase): Observable<OptionListViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -765,7 +737,7 @@ export class OptionListServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? PagedResultDtoOfOptionListViewDto.fromJS(resultData200) : new PagedResultDtoOfOptionListViewDto();
+            result200 = resultData200 ? OptionListViewDto.fromJS(resultData200) : new OptionListViewDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -773,15 +745,15 @@ export class OptionListServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<PagedResultDtoOfOptionListViewDto>(<any>null);
+        return _observableOf<OptionListViewDto>(<any>null);
     }
 
     /**
      * @param input (optional) 
      * @return Success
      */
-    create(input: OptionListCreateOrEditDto | null | undefined): Observable<OptionListViewDto> {
-        let url_ = this.baseUrl + "/api/services/app/OptionList/Create";
+    createOrUpdateList(input: OptionListCreateOrEditDto | null | undefined): Observable<void> {
+        let url_ = this.baseUrl + "/api/services/app/OptionList/CreateOrUpdateList";
         url_ = url_.replace(/[?&]$/, "");
 
         const content_ = JSON.stringify(input);
@@ -792,25 +764,24 @@ export class OptionListServiceProxy {
             responseType: "blob",
             headers: new HttpHeaders({
                 "Content-Type": "application/json", 
-                "Accept": "application/json"
             })
         };
 
         return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processCreate(response_);
+            return this.processCreateOrUpdateList(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processCreate(<any>response_);
+                    return this.processCreateOrUpdateList(<any>response_);
                 } catch (e) {
-                    return <Observable<OptionListViewDto>><any>_observableThrow(e);
+                    return <Observable<void>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<OptionListViewDto>><any>_observableThrow(response_);
+                return <Observable<void>><any>_observableThrow(response_);
         }));
     }
 
-    protected processCreate(response: HttpResponseBase): Observable<OptionListViewDto> {
+    protected processCreateOrUpdateList(response: HttpResponseBase): Observable<void> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -819,54 +790,48 @@ export class OptionListServiceProxy {
         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            let result200: any = null;
-            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? OptionListViewDto.fromJS(resultData200) : new OptionListViewDto();
-            return _observableOf(result200);
+            return _observableOf<void>(<any>null);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<OptionListViewDto>(<any>null);
+        return _observableOf<void>(<any>null);
     }
 
     /**
-     * @param input (optional) 
+     * @param id (optional) 
      * @return Success
      */
-    update(input: OptionListCreateOrEditDto | null | undefined): Observable<OptionListViewDto> {
-        let url_ = this.baseUrl + "/api/services/app/OptionList/Update";
+    deleteListByEntity(id: number | null | undefined): Observable<void> {
+        let url_ = this.baseUrl + "/api/services/app/OptionList/DeleteListByEntity?";
+        if (id !== undefined)
+            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
-        const content_ = JSON.stringify(input);
-
         let options_ : any = {
-            body: content_,
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
-                "Content-Type": "application/json", 
-                "Accept": "application/json"
             })
         };
 
-        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processUpdate(response_);
+        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processDeleteListByEntity(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processUpdate(<any>response_);
+                    return this.processDeleteListByEntity(<any>response_);
                 } catch (e) {
-                    return <Observable<OptionListViewDto>><any>_observableThrow(e);
+                    return <Observable<void>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<OptionListViewDto>><any>_observableThrow(response_);
+                return <Observable<void>><any>_observableThrow(response_);
         }));
     }
 
-    protected processUpdate(response: HttpResponseBase): Observable<OptionListViewDto> {
+    protected processDeleteListByEntity(response: HttpResponseBase): Observable<void> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -875,27 +840,24 @@ export class OptionListServiceProxy {
         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            let result200: any = null;
-            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? OptionListViewDto.fromJS(resultData200) : new OptionListViewDto();
-            return _observableOf(result200);
+            return _observableOf<void>(<any>null);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<OptionListViewDto>(<any>null);
+        return _observableOf<void>(<any>null);
     }
 
     /**
      * @param id (optional) 
      * @return Success
      */
-    delete(id: number | null | undefined): Observable<void> {
-        let url_ = this.baseUrl + "/api/services/app/OptionList/Delete?";
+    deleteList(id: number | null | undefined): Observable<void> {
+        let url_ = this.baseUrl + "/api/services/app/OptionList/DeleteList?";
         if (id !== undefined)
-            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
+            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
         let options_ : any = {
@@ -906,11 +868,11 @@ export class OptionListServiceProxy {
         };
 
         return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processDelete(response_);
+            return this.processDeleteList(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processDelete(<any>response_);
+                    return this.processDeleteList(<any>response_);
                 } catch (e) {
                     return <Observable<void>><any>_observableThrow(e);
                 }
@@ -919,7 +881,7 @@ export class OptionListServiceProxy {
         }));
     }
 
-    protected processDelete(response: HttpResponseBase): Observable<void> {
+    protected processDeleteList(response: HttpResponseBase): Observable<void> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -937,64 +899,39 @@ export class OptionListServiceProxy {
         }
         return _observableOf<void>(<any>null);
     }
-}
-
-@Injectable()
-export class OptionListItemsServiceProxy {
-    private http: HttpClient;
-    private baseUrl: string;
-    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
-
-    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
-        this.http = http;
-        this.baseUrl = baseUrl ? baseUrl : "";
-    }
 
     /**
-     * @param filter (optional) 
      * @param key (optional) 
-     * @param sorting (optional) 
-     * @param skipCount (optional) 
-     * @param maxResultCount (optional) 
      * @return Success
      */
-    getAllOptionListItems(filter: string | null | undefined, key: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfOptionListItemViewDto> {
-        let url_ = this.baseUrl + "/api/services/app/OptionListItems/GetAllOptionListItems?";
-        if (filter !== undefined)
-            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
+    deleteListItemsByList(key: string | null | undefined): Observable<void> {
+        let url_ = this.baseUrl + "/api/services/app/OptionList/DeleteListItemsByList?";
         if (key !== undefined)
-            url_ += "Key=" + encodeURIComponent("" + key) + "&"; 
-        if (sorting !== undefined)
-            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
-        if (skipCount !== undefined)
-            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
-        if (maxResultCount !== undefined)
-            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
+            url_ += "key=" + encodeURIComponent("" + key) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
         let options_ : any = {
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
-                "Accept": "application/json"
             })
         };
 
-        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetAllOptionListItems(response_);
+        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processDeleteListItemsByList(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetAllOptionListItems(<any>response_);
+                    return this.processDeleteListItemsByList(<any>response_);
                 } catch (e) {
-                    return <Observable<PagedResultDtoOfOptionListItemViewDto>><any>_observableThrow(e);
+                    return <Observable<void>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<PagedResultDtoOfOptionListItemViewDto>><any>_observableThrow(response_);
+                return <Observable<void>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGetAllOptionListItems(response: HttpResponseBase): Observable<PagedResultDtoOfOptionListItemViewDto> {
+    protected processDeleteListItemsByList(response: HttpResponseBase): Observable<void> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -1003,25 +940,22 @@ export class OptionListItemsServiceProxy {
         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            let result200: any = null;
-            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? PagedResultDtoOfOptionListItemViewDto.fromJS(resultData200) : new PagedResultDtoOfOptionListItemViewDto();
-            return _observableOf(result200);
+            return _observableOf<void>(<any>null);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<PagedResultDtoOfOptionListItemViewDto>(<any>null);
+        return _observableOf<void>(<any>null);
     }
 
     /**
      * @param id (optional) 
      * @return Success
      */
-    getListItemByEntityId(id: number | null | undefined): Observable<OptionListItemViewDto> {
-        let url_ = this.baseUrl + "/api/services/app/OptionListItems/GetListItemByEntityId?";
+    get(id: number | null | undefined): Observable<OptionListViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/OptionList/Get?";
         if (id !== undefined)
             url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
@@ -1035,20 +969,20 @@ export class OptionListItemsServiceProxy {
         };
 
         return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetListItemByEntityId(response_);
+            return this.processGet(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetListItemByEntityId(<any>response_);
+                    return this.processGet(<any>response_);
                 } catch (e) {
-                    return <Observable<OptionListItemViewDto>><any>_observableThrow(e);
+                    return <Observable<OptionListViewDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<OptionListItemViewDto>><any>_observableThrow(response_);
+                return <Observable<OptionListViewDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGetListItemByEntityId(response: HttpResponseBase): Observable<OptionListItemViewDto> {
+    protected processGet(response: HttpResponseBase): Observable<OptionListViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -1059,7 +993,7 @@ export class OptionListItemsServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? OptionListItemViewDto.fromJS(resultData200) : new OptionListItemViewDto();
+            result200 = resultData200 ? OptionListViewDto.fromJS(resultData200) : new OptionListViewDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -1067,17 +1001,29 @@ export class OptionListItemsServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<OptionListItemViewDto>(<any>null);
+        return _observableOf<OptionListViewDto>(<any>null);
     }
 
     /**
-     * @param id (optional) 
+     * @param filter (optional) 
+     * @param key (optional) 
+     * @param sorting (optional) 
+     * @param skipCount (optional) 
+     * @param maxResultCount (optional) 
      * @return Success
      */
-    getListItemById(id: number | null | undefined): Observable<OptionListItemViewDto> {
-        let url_ = this.baseUrl + "/api/services/app/OptionListItems/GetListItemById?";
-        if (id !== undefined)
-            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
+    getAll(filter: string | null | undefined, key: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfOptionListViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/OptionList/GetAll?";
+        if (filter !== undefined)
+            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
+        if (key !== undefined)
+            url_ += "Key=" + encodeURIComponent("" + key) + "&"; 
+        if (sorting !== undefined)
+            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
+        if (skipCount !== undefined)
+            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
+        if (maxResultCount !== undefined)
+            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
         let options_ : any = {
@@ -1089,20 +1035,20 @@ export class OptionListItemsServiceProxy {
         };
 
         return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetListItemById(response_);
+            return this.processGetAll(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetListItemById(<any>response_);
+                    return this.processGetAll(<any>response_);
                 } catch (e) {
-                    return <Observable<OptionListItemViewDto>><any>_observableThrow(e);
+                    return <Observable<PagedResultDtoOfOptionListViewDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<OptionListItemViewDto>><any>_observableThrow(response_);
+                return <Observable<PagedResultDtoOfOptionListViewDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGetListItemById(response: HttpResponseBase): Observable<OptionListItemViewDto> {
+    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfOptionListViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -1113,7 +1059,7 @@ export class OptionListItemsServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? OptionListItemViewDto.fromJS(resultData200) : new OptionListItemViewDto();
+            result200 = resultData200 ? PagedResultDtoOfOptionListViewDto.fromJS(resultData200) : new PagedResultDtoOfOptionListViewDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -1121,54 +1067,44 @@ export class OptionListItemsServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<OptionListItemViewDto>(<any>null);
+        return _observableOf<PagedResultDtoOfOptionListViewDto>(<any>null);
     }
 
     /**
-     * @param filter (optional) 
-     * @param key (optional) 
-     * @param sorting (optional) 
-     * @param skipCount (optional) 
-     * @param maxResultCount (optional) 
+     * @param input (optional) 
      * @return Success
      */
-    getListItemsByListKey(filter: string | null | undefined, key: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfOptionListItemViewDto> {
-        let url_ = this.baseUrl + "/api/services/app/OptionListItems/GetListItemsByListKey?";
-        if (filter !== undefined)
-            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
-        if (key !== undefined)
-            url_ += "Key=" + encodeURIComponent("" + key) + "&"; 
-        if (sorting !== undefined)
-            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
-        if (skipCount !== undefined)
-            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
-        if (maxResultCount !== undefined)
-            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
+    create(input: OptionListCreateOrEditDto | null | undefined): Observable<OptionListViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/OptionList/Create";
         url_ = url_.replace(/[?&]$/, "");
 
+        const content_ = JSON.stringify(input);
+
         let options_ : any = {
+            body: content_,
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
+                "Content-Type": "application/json", 
                 "Accept": "application/json"
             })
         };
 
-        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetListItemsByListKey(response_);
+        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processCreate(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetListItemsByListKey(<any>response_);
+                    return this.processCreate(<any>response_);
                 } catch (e) {
-                    return <Observable<PagedResultDtoOfOptionListItemViewDto>><any>_observableThrow(e);
+                    return <Observable<OptionListViewDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<PagedResultDtoOfOptionListItemViewDto>><any>_observableThrow(response_);
+                return <Observable<OptionListViewDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGetListItemsByListKey(response: HttpResponseBase): Observable<PagedResultDtoOfOptionListItemViewDto> {
+    protected processCreate(response: HttpResponseBase): Observable<OptionListViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -1179,7 +1115,7 @@ export class OptionListItemsServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? PagedResultDtoOfOptionListItemViewDto.fromJS(resultData200) : new PagedResultDtoOfOptionListItemViewDto();
+            result200 = resultData200 ? OptionListViewDto.fromJS(resultData200) : new OptionListViewDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -1187,15 +1123,15 @@ export class OptionListItemsServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<PagedResultDtoOfOptionListItemViewDto>(<any>null);
+        return _observableOf<OptionListViewDto>(<any>null);
     }
 
     /**
      * @param input (optional) 
      * @return Success
      */
-    createOrUpdateListItem(input: OptionListItemCreateOrEditDto | null | undefined): Observable<void> {
-        let url_ = this.baseUrl + "/api/services/app/OptionListItems/CreateOrUpdateListItem";
+    update(input: OptionListCreateOrEditDto | null | undefined): Observable<OptionListViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/OptionList/Update";
         url_ = url_.replace(/[?&]$/, "");
 
         const content_ = JSON.stringify(input);
@@ -1206,24 +1142,25 @@ export class OptionListItemsServiceProxy {
             responseType: "blob",
             headers: new HttpHeaders({
                 "Content-Type": "application/json", 
+                "Accept": "application/json"
             })
         };
 
-        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processCreateOrUpdateListItem(response_);
+        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processUpdate(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processCreateOrUpdateListItem(<any>response_);
+                    return this.processUpdate(<any>response_);
                 } catch (e) {
-                    return <Observable<void>><any>_observableThrow(e);
+                    return <Observable<OptionListViewDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<void>><any>_observableThrow(response_);
+                return <Observable<OptionListViewDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processCreateOrUpdateListItem(response: HttpResponseBase): Observable<void> {
+    protected processUpdate(response: HttpResponseBase): Observable<OptionListViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -1232,24 +1169,27 @@ export class OptionListItemsServiceProxy {
         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            return _observableOf<void>(<any>null);
+            let result200: any = null;
+            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
+            result200 = resultData200 ? OptionListViewDto.fromJS(resultData200) : new OptionListViewDto();
+            return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<void>(<any>null);
+        return _observableOf<OptionListViewDto>(<any>null);
     }
 
     /**
-     * @param key (optional) 
+     * @param id (optional) 
      * @return Success
      */
-    deleteAllListItemsByListKey(key: string | null | undefined): Observable<void> {
-        let url_ = this.baseUrl + "/api/services/app/OptionListItems/DeleteAllListItemsByListKey?";
-        if (key !== undefined)
-            url_ += "key=" + encodeURIComponent("" + key) + "&"; 
+    delete(id: number | null | undefined): Observable<void> {
+        let url_ = this.baseUrl + "/api/services/app/OptionList/Delete?";
+        if (id !== undefined)
+            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
         let options_ : any = {
@@ -1260,11 +1200,11 @@ export class OptionListItemsServiceProxy {
         };
 
         return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processDeleteAllListItemsByListKey(response_);
+            return this.processDelete(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processDeleteAllListItemsByListKey(<any>response_);
+                    return this.processDelete(<any>response_);
                 } catch (e) {
                     return <Observable<void>><any>_observableThrow(e);
                 }
@@ -1273,7 +1213,7 @@ export class OptionListItemsServiceProxy {
         }));
     }
 
-    protected processDeleteAllListItemsByListKey(response: HttpResponseBase): Observable<void> {
+    protected processDelete(response: HttpResponseBase): Observable<void> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -1291,39 +1231,64 @@ export class OptionListItemsServiceProxy {
         }
         return _observableOf<void>(<any>null);
     }
+}
 
-    /**
-     * @param id (optional) 
-     * @return Success
-     */
-    deleteListItemByEntity(id: number | null | undefined): Observable<void> {
-        let url_ = this.baseUrl + "/api/services/app/OptionListItems/DeleteListItemByEntity?";
-        if (id !== undefined)
-            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
+@Injectable()
+export class OptionListItemsServiceProxy {
+    private http: HttpClient;
+    private baseUrl: string;
+    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
+
+    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
+        this.http = http;
+        this.baseUrl = baseUrl ? baseUrl : "";
+    }
+
+    /**
+     * @param filter (optional) 
+     * @param key (optional) 
+     * @param sorting (optional) 
+     * @param skipCount (optional) 
+     * @param maxResultCount (optional) 
+     * @return Success
+     */
+    getAllOptionListItems(filter: string | null | undefined, key: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfOptionListItemViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/OptionListItems/GetAllOptionListItems?";
+        if (filter !== undefined)
+            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
+        if (key !== undefined)
+            url_ += "Key=" + encodeURIComponent("" + key) + "&"; 
+        if (sorting !== undefined)
+            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
+        if (skipCount !== undefined)
+            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
+        if (maxResultCount !== undefined)
+            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
         let options_ : any = {
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
+                "Accept": "application/json"
             })
         };
 
-        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processDeleteListItemByEntity(response_);
+        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processGetAllOptionListItems(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processDeleteListItemByEntity(<any>response_);
+                    return this.processGetAllOptionListItems(<any>response_);
                 } catch (e) {
-                    return <Observable<void>><any>_observableThrow(e);
+                    return <Observable<PagedResultDtoOfOptionListItemViewDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<void>><any>_observableThrow(response_);
+                return <Observable<PagedResultDtoOfOptionListItemViewDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processDeleteListItemByEntity(response: HttpResponseBase): Observable<void> {
+    protected processGetAllOptionListItems(response: HttpResponseBase): Observable<PagedResultDtoOfOptionListItemViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -1332,48 +1297,52 @@ export class OptionListItemsServiceProxy {
         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            return _observableOf<void>(<any>null);
+            let result200: any = null;
+            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
+            result200 = resultData200 ? PagedResultDtoOfOptionListItemViewDto.fromJS(resultData200) : new PagedResultDtoOfOptionListItemViewDto();
+            return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<void>(<any>null);
+        return _observableOf<PagedResultDtoOfOptionListItemViewDto>(<any>null);
     }
 
     /**
      * @param id (optional) 
      * @return Success
      */
-    deleteListItem(id: number | null | undefined): Observable<void> {
-        let url_ = this.baseUrl + "/api/services/app/OptionListItems/DeleteListItem?";
+    getListItemByEntityId(id: number | null | undefined): Observable<OptionListItemViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/OptionListItems/GetListItemByEntityId?";
         if (id !== undefined)
-            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
+            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
         let options_ : any = {
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
+                "Accept": "application/json"
             })
         };
 
-        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processDeleteListItem(response_);
+        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processGetListItemByEntityId(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processDeleteListItem(<any>response_);
+                    return this.processGetListItemByEntityId(<any>response_);
                 } catch (e) {
-                    return <Observable<void>><any>_observableThrow(e);
+                    return <Observable<OptionListItemViewDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<void>><any>_observableThrow(response_);
+                return <Observable<OptionListItemViewDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processDeleteListItem(response: HttpResponseBase): Observable<void> {
+    protected processGetListItemByEntityId(response: HttpResponseBase): Observable<OptionListItemViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -1382,24 +1351,27 @@ export class OptionListItemsServiceProxy {
         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            return _observableOf<void>(<any>null);
+            let result200: any = null;
+            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
+            result200 = resultData200 ? OptionListItemViewDto.fromJS(resultData200) : new OptionListItemViewDto();
+            return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<void>(<any>null);
+        return _observableOf<OptionListItemViewDto>(<any>null);
     }
 
     /**
      * @param id (optional) 
      * @return Success
      */
-    get(id: number | null | undefined): Observable<OptionListItemViewDto> {
-        let url_ = this.baseUrl + "/api/services/app/OptionListItems/Get?";
+    getListItemById(id: number | null | undefined): Observable<OptionListItemViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/OptionListItems/GetListItemById?";
         if (id !== undefined)
-            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
+            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
         let options_ : any = {
@@ -1411,11 +1383,11 @@ export class OptionListItemsServiceProxy {
         };
 
         return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGet(response_);
+            return this.processGetListItemById(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGet(<any>response_);
+                    return this.processGetListItemById(<any>response_);
                 } catch (e) {
                     return <Observable<OptionListItemViewDto>><any>_observableThrow(e);
                 }
@@ -1424,7 +1396,7 @@ export class OptionListItemsServiceProxy {
         }));
     }
 
-    protected processGet(response: HttpResponseBase): Observable<OptionListItemViewDto> {
+    protected processGetListItemById(response: HttpResponseBase): Observable<OptionListItemViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -1454,8 +1426,8 @@ export class OptionListItemsServiceProxy {
      * @param maxResultCount (optional) 
      * @return Success
      */
-    getAll(filter: string | null | undefined, key: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfOptionListItemViewDto> {
-        let url_ = this.baseUrl + "/api/services/app/OptionListItems/GetAll?";
+    getListItemsByListKey(filter: string | null | undefined, key: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfOptionListItemViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/OptionListItems/GetListItemsByListKey?";
         if (filter !== undefined)
             url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
         if (key !== undefined)
@@ -1477,11 +1449,11 @@ export class OptionListItemsServiceProxy {
         };
 
         return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetAll(response_);
+            return this.processGetListItemsByListKey(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetAll(<any>response_);
+                    return this.processGetListItemsByListKey(<any>response_);
                 } catch (e) {
                     return <Observable<PagedResultDtoOfOptionListItemViewDto>><any>_observableThrow(e);
                 }
@@ -1490,7 +1462,7 @@ export class OptionListItemsServiceProxy {
         }));
     }
 
-    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfOptionListItemViewDto> {
+    protected processGetListItemsByListKey(response: HttpResponseBase): Observable<PagedResultDtoOfOptionListItemViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -1516,8 +1488,8 @@ export class OptionListItemsServiceProxy {
      * @param input (optional) 
      * @return Success
      */
-    create(input: OptionListItemCreateOrEditDto | null | undefined): Observable<OptionListItemViewDto> {
-        let url_ = this.baseUrl + "/api/services/app/OptionListItems/Create";
+    createOrUpdateListItem(input: OptionListItemCreateOrEditDto | null | undefined): Observable<void> {
+        let url_ = this.baseUrl + "/api/services/app/OptionListItems/CreateOrUpdateListItem";
         url_ = url_.replace(/[?&]$/, "");
 
         const content_ = JSON.stringify(input);
@@ -1528,25 +1500,24 @@ export class OptionListItemsServiceProxy {
             responseType: "blob",
             headers: new HttpHeaders({
                 "Content-Type": "application/json", 
-                "Accept": "application/json"
             })
         };
 
         return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processCreate(response_);
+            return this.processCreateOrUpdateListItem(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processCreate(<any>response_);
+                    return this.processCreateOrUpdateListItem(<any>response_);
                 } catch (e) {
-                    return <Observable<OptionListItemViewDto>><any>_observableThrow(e);
+                    return <Observable<void>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<OptionListItemViewDto>><any>_observableThrow(response_);
+                return <Observable<void>><any>_observableThrow(response_);
         }));
     }
 
-    protected processCreate(response: HttpResponseBase): Observable<OptionListItemViewDto> {
+    protected processCreateOrUpdateListItem(response: HttpResponseBase): Observable<void> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -1555,54 +1526,48 @@ export class OptionListItemsServiceProxy {
         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            let result200: any = null;
-            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? OptionListItemViewDto.fromJS(resultData200) : new OptionListItemViewDto();
-            return _observableOf(result200);
+            return _observableOf<void>(<any>null);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<OptionListItemViewDto>(<any>null);
+        return _observableOf<void>(<any>null);
     }
 
     /**
-     * @param input (optional) 
+     * @param key (optional) 
      * @return Success
      */
-    update(input: OptionListItemCreateOrEditDto | null | undefined): Observable<OptionListItemViewDto> {
-        let url_ = this.baseUrl + "/api/services/app/OptionListItems/Update";
+    deleteAllListItemsByListKey(key: string | null | undefined): Observable<void> {
+        let url_ = this.baseUrl + "/api/services/app/OptionListItems/DeleteAllListItemsByListKey?";
+        if (key !== undefined)
+            url_ += "key=" + encodeURIComponent("" + key) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
-        const content_ = JSON.stringify(input);
-
         let options_ : any = {
-            body: content_,
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
-                "Content-Type": "application/json", 
-                "Accept": "application/json"
             })
         };
 
-        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processUpdate(response_);
+        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processDeleteAllListItemsByListKey(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processUpdate(<any>response_);
+                    return this.processDeleteAllListItemsByListKey(<any>response_);
                 } catch (e) {
-                    return <Observable<OptionListItemViewDto>><any>_observableThrow(e);
+                    return <Observable<void>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<OptionListItemViewDto>><any>_observableThrow(response_);
+                return <Observable<void>><any>_observableThrow(response_);
         }));
     }
 
-    protected processUpdate(response: HttpResponseBase): Observable<OptionListItemViewDto> {
+    protected processDeleteAllListItemsByListKey(response: HttpResponseBase): Observable<void> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -1611,25 +1576,22 @@ export class OptionListItemsServiceProxy {
         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            let result200: any = null;
-            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? OptionListItemViewDto.fromJS(resultData200) : new OptionListItemViewDto();
-            return _observableOf(result200);
+            return _observableOf<void>(<any>null);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<OptionListItemViewDto>(<any>null);
+        return _observableOf<void>(<any>null);
     }
 
     /**
      * @param id (optional) 
      * @return Success
      */
-    delete(id: number | null | undefined): Observable<void> {
-        let url_ = this.baseUrl + "/api/services/app/OptionListItems/Delete?";
+    deleteListItemByEntity(id: number | null | undefined): Observable<void> {
+        let url_ = this.baseUrl + "/api/services/app/OptionListItems/DeleteListItemByEntity?";
         if (id !== undefined)
             url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
@@ -1642,11 +1604,11 @@ export class OptionListItemsServiceProxy {
         };
 
         return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processDelete(response_);
+            return this.processDeleteListItemByEntity(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processDelete(<any>response_);
+                    return this.processDeleteListItemByEntity(<any>response_);
                 } catch (e) {
                     return <Observable<void>><any>_observableThrow(e);
                 }
@@ -1655,7 +1617,7 @@ export class OptionListItemsServiceProxy {
         }));
     }
 
-    protected processDelete(response: HttpResponseBase): Observable<void> {
+    protected processDeleteListItemByEntity(response: HttpResponseBase): Observable<void> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -1673,54 +1635,39 @@ export class OptionListItemsServiceProxy {
         }
         return _observableOf<void>(<any>null);
     }
-}
-
-@Injectable()
-export class RoleServiceProxy {
-    private http: HttpClient;
-    private baseUrl: string;
-    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
-
-    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
-        this.http = http;
-        this.baseUrl = baseUrl ? baseUrl : "";
-    }
 
     /**
-     * @param input (optional) 
+     * @param id (optional) 
      * @return Success
      */
-    create(input: CreateRoleDto | null | undefined): Observable<RoleDto> {
-        let url_ = this.baseUrl + "/api/services/app/Role/Create";
+    deleteListItem(id: number | null | undefined): Observable<void> {
+        let url_ = this.baseUrl + "/api/services/app/OptionListItems/DeleteListItem?";
+        if (id !== undefined)
+            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
-        const content_ = JSON.stringify(input);
-
         let options_ : any = {
-            body: content_,
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
-                "Content-Type": "application/json", 
-                "Accept": "application/json"
             })
         };
 
-        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processCreate(response_);
+        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processDeleteListItem(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processCreate(<any>response_);
+                    return this.processDeleteListItem(<any>response_);
                 } catch (e) {
-                    return <Observable<RoleDto>><any>_observableThrow(e);
+                    return <Observable<void>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<RoleDto>><any>_observableThrow(response_);
+                return <Observable<void>><any>_observableThrow(response_);
         }));
     }
 
-    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
+    protected processDeleteListItem(response: HttpResponseBase): Observable<void> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -1729,27 +1676,24 @@ export class RoleServiceProxy {
         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            let result200: any = null;
-            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
-            return _observableOf(result200);
+            return _observableOf<void>(<any>null);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<RoleDto>(<any>null);
+        return _observableOf<void>(<any>null);
     }
 
     /**
-     * @param permission (optional) 
+     * @param id (optional) 
      * @return Success
      */
-    getRolesAsync(permission: string | null | undefined): Observable<ListResultDtoOfRoleListDto> {
-        let url_ = this.baseUrl + "/api/services/app/Role/GetRolesAsync?";
-        if (permission !== undefined)
-            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
+    get(id: number | null | undefined): Observable<OptionListItemViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/OptionListItems/Get?";
+        if (id !== undefined)
+            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
         let options_ : any = {
@@ -1761,20 +1705,20 @@ export class RoleServiceProxy {
         };
 
         return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetRolesAsync(response_);
+            return this.processGet(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetRolesAsync(<any>response_);
+                    return this.processGet(<any>response_);
                 } catch (e) {
-                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
+                    return <Observable<OptionListItemViewDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
+                return <Observable<OptionListItemViewDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGetRolesAsync(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
+    protected processGet(response: HttpResponseBase): Observable<OptionListItemViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -1785,7 +1729,7 @@ export class RoleServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
+            result200 = resultData200 ? OptionListItemViewDto.fromJS(resultData200) : new OptionListItemViewDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -1793,44 +1737,54 @@ export class RoleServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
+        return _observableOf<OptionListItemViewDto>(<any>null);
     }
 
     /**
-     * @param input (optional) 
+     * @param filter (optional) 
+     * @param key (optional) 
+     * @param sorting (optional) 
+     * @param skipCount (optional) 
+     * @param maxResultCount (optional) 
      * @return Success
      */
-    update(input: RoleDto | null | undefined): Observable<RoleDto> {
-        let url_ = this.baseUrl + "/api/services/app/Role/Update";
+    getAll(filter: string | null | undefined, key: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfOptionListItemViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/OptionListItems/GetAll?";
+        if (filter !== undefined)
+            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
+        if (key !== undefined)
+            url_ += "Key=" + encodeURIComponent("" + key) + "&"; 
+        if (sorting !== undefined)
+            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
+        if (skipCount !== undefined)
+            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
+        if (maxResultCount !== undefined)
+            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
-        const content_ = JSON.stringify(input);
-
         let options_ : any = {
-            body: content_,
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
-                "Content-Type": "application/json", 
                 "Accept": "application/json"
             })
         };
 
-        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processUpdate(response_);
+        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processGetAll(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processUpdate(<any>response_);
+                    return this.processGetAll(<any>response_);
                 } catch (e) {
-                    return <Observable<RoleDto>><any>_observableThrow(e);
+                    return <Observable<PagedResultDtoOfOptionListItemViewDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<RoleDto>><any>_observableThrow(response_);
+                return <Observable<PagedResultDtoOfOptionListItemViewDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
+    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfOptionListItemViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -1841,7 +1795,7 @@ export class RoleServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
+            result200 = resultData200 ? PagedResultDtoOfOptionListItemViewDto.fromJS(resultData200) : new PagedResultDtoOfOptionListItemViewDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -1849,89 +1803,44 @@ export class RoleServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<RoleDto>(<any>null);
+        return _observableOf<PagedResultDtoOfOptionListItemViewDto>(<any>null);
     }
 
     /**
-     * @param id (optional) 
+     * @param input (optional) 
      * @return Success
      */
-    delete(id: number | null | undefined): Observable<void> {
-        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
-        if (id !== undefined)
-            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
+    create(input: OptionListItemCreateOrEditDto | null | undefined): Observable<OptionListItemViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/OptionListItems/Create";
         url_ = url_.replace(/[?&]$/, "");
 
-        let options_ : any = {
-            observe: "response",
-            responseType: "blob",
-            headers: new HttpHeaders({
-            })
-        };
-
-        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processDelete(response_);
-        })).pipe(_observableCatch((response_: any) => {
-            if (response_ instanceof HttpResponseBase) {
-                try {
-                    return this.processDelete(<any>response_);
-                } catch (e) {
-                    return <Observable<void>><any>_observableThrow(e);
-                }
-            } else
-                return <Observable<void>><any>_observableThrow(response_);
-        }));
-    }
-
-    protected processDelete(response: HttpResponseBase): Observable<void> {
-        const status = response.status;
-        const responseBlob = 
-            response instanceof HttpResponse ? response.body : 
-            (<any>response).error instanceof Blob ? (<any>response).error : undefined;
-
-        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
-        if (status === 200) {
-            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            return _observableOf<void>(<any>null);
-            }));
-        } else if (status !== 200 && status !== 204) {
-            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
-            }));
-        }
-        return _observableOf<void>(<any>null);
-    }
-
-    /**
-     * @return Success
-     */
-    getAllPermissions(): Observable<ListResultDtoOfPermissionDto> {
-        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
-        url_ = url_.replace(/[?&]$/, "");
+        const content_ = JSON.stringify(input);
 
         let options_ : any = {
+            body: content_,
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
+                "Content-Type": "application/json", 
                 "Accept": "application/json"
             })
         };
 
-        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetAllPermissions(response_);
+        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processCreate(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetAllPermissions(<any>response_);
+                    return this.processCreate(<any>response_);
                 } catch (e) {
-                    return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(e);
+                    return <Observable<OptionListItemViewDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(response_);
+                return <Observable<OptionListItemViewDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfPermissionDto> {
+    protected processCreate(response: HttpResponseBase): Observable<OptionListItemViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -1942,7 +1851,7 @@ export class RoleServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? ListResultDtoOfPermissionDto.fromJS(resultData200) : new ListResultDtoOfPermissionDto();
+            result200 = resultData200 ? OptionListItemViewDto.fromJS(resultData200) : new OptionListItemViewDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -1950,42 +1859,44 @@ export class RoleServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<ListResultDtoOfPermissionDto>(<any>null);
+        return _observableOf<OptionListItemViewDto>(<any>null);
     }
 
     /**
-     * @param id (optional) 
+     * @param input (optional) 
      * @return Success
      */
-    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
-        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
-        if (id !== undefined)
-            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
+    update(input: OptionListItemCreateOrEditDto | null | undefined): Observable<OptionListItemViewDto> {
+        let url_ = this.baseUrl + "/api/services/app/OptionListItems/Update";
         url_ = url_.replace(/[?&]$/, "");
 
+        const content_ = JSON.stringify(input);
+
         let options_ : any = {
+            body: content_,
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
+                "Content-Type": "application/json", 
                 "Accept": "application/json"
             })
         };
 
-        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetRoleForEdit(response_);
+        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processUpdate(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetRoleForEdit(<any>response_);
+                    return this.processUpdate(<any>response_);
                 } catch (e) {
-                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
+                    return <Observable<OptionListItemViewDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
+                return <Observable<OptionListItemViewDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
+    protected processUpdate(response: HttpResponseBase): Observable<OptionListItemViewDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -1996,7 +1907,7 @@ export class RoleServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
+            result200 = resultData200 ? OptionListItemViewDto.fromJS(resultData200) : new OptionListItemViewDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -2004,15 +1915,15 @@ export class RoleServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<GetRoleForEditOutput>(<any>null);
+        return _observableOf<OptionListItemViewDto>(<any>null);
     }
 
     /**
      * @param id (optional) 
      * @return Success
      */
-    get(id: number | null | undefined): Observable<RoleDto> {
-        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
+    delete(id: number | null | undefined): Observable<void> {
+        let url_ = this.baseUrl + "/api/services/app/OptionListItems/Delete?";
         if (id !== undefined)
             url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
@@ -2021,25 +1932,24 @@ export class RoleServiceProxy {
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
-                "Accept": "application/json"
             })
         };
 
-        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGet(response_);
+        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processDelete(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGet(<any>response_);
+                    return this.processDelete(<any>response_);
                 } catch (e) {
-                    return <Observable<RoleDto>><any>_observableThrow(e);
+                    return <Observable<void>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<RoleDto>><any>_observableThrow(response_);
+                return <Observable<void>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
+    protected processDelete(response: HttpResponseBase): Observable<void> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -2048,58 +1958,63 @@ export class RoleServiceProxy {
         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            let result200: any = null;
-            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
-            return _observableOf(result200);
+            return _observableOf<void>(<any>null);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<RoleDto>(<any>null);
+        return _observableOf<void>(<any>null);
+    }
+}
+
+@Injectable()
+export class RoleServiceProxy {
+    private http: HttpClient;
+    private baseUrl: string;
+    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
+
+    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
+        this.http = http;
+        this.baseUrl = baseUrl ? baseUrl : "";
     }
 
     /**
-     * @param keyword (optional) 
-     * @param skipCount (optional) 
-     * @param maxResultCount (optional) 
+     * @param input (optional) 
      * @return Success
      */
-    getAll(keyword: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRoleDto> {
-        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
-        if (keyword !== undefined)
-            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
-        if (skipCount !== undefined)
-            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
-        if (maxResultCount !== undefined)
-            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
+    create(input: CreateRoleDto | null | undefined): Observable<RoleDto> {
+        let url_ = this.baseUrl + "/api/services/app/Role/Create";
         url_ = url_.replace(/[?&]$/, "");
 
+        const content_ = JSON.stringify(input);
+
         let options_ : any = {
+            body: content_,
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
+                "Content-Type": "application/json", 
                 "Accept": "application/json"
             })
         };
 
-        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetAll(response_);
+        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processCreate(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetAll(<any>response_);
+                    return this.processCreate(<any>response_);
                 } catch (e) {
-                    return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(e);
+                    return <Observable<RoleDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(response_);
+                return <Observable<RoleDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfRoleDto> {
+    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -2110,7 +2025,7 @@ export class RoleServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? PagedResultDtoOfRoleDto.fromJS(resultData200) : new PagedResultDtoOfRoleDto();
+            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -2118,26 +2033,17 @@ export class RoleServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<PagedResultDtoOfRoleDto>(<any>null);
-    }
-}
-
-@Injectable()
-export class SessionServiceProxy {
-    private http: HttpClient;
-    private baseUrl: string;
-    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
-
-    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
-        this.http = http;
-        this.baseUrl = baseUrl ? baseUrl : "";
+        return _observableOf<RoleDto>(<any>null);
     }
 
     /**
+     * @param permission (optional) 
      * @return Success
      */
-    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
-        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
+    getRolesAsync(permission: string | null | undefined): Observable<ListResultDtoOfRoleListDto> {
+        let url_ = this.baseUrl + "/api/services/app/Role/GetRolesAsync?";
+        if (permission !== undefined)
+            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
         let options_ : any = {
@@ -2149,20 +2055,20 @@ export class SessionServiceProxy {
         };
 
         return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetCurrentLoginInformations(response_);
+            return this.processGetRolesAsync(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetCurrentLoginInformations(<any>response_);
+                    return this.processGetRolesAsync(<any>response_);
                 } catch (e) {
-                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
+                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
+                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
+    protected processGetRolesAsync(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -2173,7 +2079,7 @@ export class SessionServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
+            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -2181,27 +2087,15 @@ export class SessionServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
-    }
-}
-
-@Injectable()
-export class TenantServiceProxy {
-    private http: HttpClient;
-    private baseUrl: string;
-    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
-
-    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
-        this.http = http;
-        this.baseUrl = baseUrl ? baseUrl : "";
+        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
     }
 
     /**
      * @param input (optional) 
      * @return Success
      */
-    create(input: CreateTenantDto | null | undefined): Observable<TenantDto> {
-        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
+    update(input: RoleDto | null | undefined): Observable<RoleDto> {
+        let url_ = this.baseUrl + "/api/services/app/Role/Update";
         url_ = url_.replace(/[?&]$/, "");
 
         const content_ = JSON.stringify(input);
@@ -2216,21 +2110,21 @@ export class TenantServiceProxy {
             })
         };
 
-        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processCreate(response_);
+        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processUpdate(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processCreate(<any>response_);
+                    return this.processUpdate(<any>response_);
                 } catch (e) {
-                    return <Observable<TenantDto>><any>_observableThrow(e);
+                    return <Observable<RoleDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<TenantDto>><any>_observableThrow(response_);
+                return <Observable<RoleDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
+    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -2241,7 +2135,7 @@ export class TenantServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
+            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -2249,7 +2143,7 @@ export class TenantServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<TenantDto>(<any>null);
+        return _observableOf<RoleDto>(<any>null);
     }
 
     /**
@@ -2257,7 +2151,7 @@ export class TenantServiceProxy {
      * @return Success
      */
     delete(id: number | null | undefined): Observable<void> {
-        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
+        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
         if (id !== undefined)
             url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
@@ -2303,13 +2197,10 @@ export class TenantServiceProxy {
     }
 
     /**
-     * @param id (optional) 
      * @return Success
      */
-    get(id: number | null | undefined): Observable<TenantDto> {
-        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
-        if (id !== undefined)
-            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
+    getAllPermissions(): Observable<ListResultDtoOfPermissionDto> {
+        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
         url_ = url_.replace(/[?&]$/, "");
 
         let options_ : any = {
@@ -2321,20 +2212,20 @@ export class TenantServiceProxy {
         };
 
         return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGet(response_);
+            return this.processGetAllPermissions(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGet(<any>response_);
+                    return this.processGetAllPermissions(<any>response_);
                 } catch (e) {
-                    return <Observable<TenantDto>><any>_observableThrow(e);
+                    return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<TenantDto>><any>_observableThrow(response_);
+                return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
+    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfPermissionDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -2345,7 +2236,7 @@ export class TenantServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
+            result200 = resultData200 ? ListResultDtoOfPermissionDto.fromJS(resultData200) : new ListResultDtoOfPermissionDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -2353,26 +2244,17 @@ export class TenantServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<TenantDto>(<any>null);
+        return _observableOf<ListResultDtoOfPermissionDto>(<any>null);
     }
 
     /**
-     * @param keyword (optional) 
-     * @param isActive (optional) 
-     * @param skipCount (optional) 
-     * @param maxResultCount (optional) 
+     * @param id (optional) 
      * @return Success
      */
-    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfTenantDto> {
-        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
-        if (keyword !== undefined)
-            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
-        if (isActive !== undefined)
-            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
-        if (skipCount !== undefined)
-            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
-        if (maxResultCount !== undefined)
-            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
+    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
+        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
+        if (id !== undefined)
+            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
         let options_ : any = {
@@ -2384,20 +2266,20 @@ export class TenantServiceProxy {
         };
 
         return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetAll(response_);
+            return this.processGetRoleForEdit(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetAll(<any>response_);
+                    return this.processGetRoleForEdit(<any>response_);
                 } catch (e) {
-                    return <Observable<PagedResultDtoOfTenantDto>><any>_observableThrow(e);
+                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<PagedResultDtoOfTenantDto>><any>_observableThrow(response_);
+                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTenantDto> {
+    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -2408,7 +2290,7 @@ export class TenantServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? PagedResultDtoOfTenantDto.fromJS(resultData200) : new PagedResultDtoOfTenantDto();
+            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -2416,44 +2298,42 @@ export class TenantServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<PagedResultDtoOfTenantDto>(<any>null);
+        return _observableOf<GetRoleForEditOutput>(<any>null);
     }
 
     /**
-     * @param input (optional) 
+     * @param id (optional) 
      * @return Success
      */
-    update(input: TenantDto | null | undefined): Observable<TenantDto> {
-        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
+    get(id: number | null | undefined): Observable<RoleDto> {
+        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
+        if (id !== undefined)
+            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
-        const content_ = JSON.stringify(input);
-
         let options_ : any = {
-            body: content_,
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
-                "Content-Type": "application/json", 
                 "Accept": "application/json"
             })
         };
 
-        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processUpdate(response_);
+        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processGet(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processUpdate(<any>response_);
+                    return this.processGet(<any>response_);
                 } catch (e) {
-                    return <Observable<TenantDto>><any>_observableThrow(e);
+                    return <Observable<RoleDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<TenantDto>><any>_observableThrow(response_);
+                return <Observable<RoleDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
+    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -2464,7 +2344,7 @@ export class TenantServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
+            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -2472,56 +2352,48 @@ export class TenantServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<TenantDto>(<any>null);
-    }
-}
-
-@Injectable()
-export class TokenAuthServiceProxy {
-    private http: HttpClient;
-    private baseUrl: string;
-    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
-
-    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
-        this.http = http;
-        this.baseUrl = baseUrl ? baseUrl : "";
+        return _observableOf<RoleDto>(<any>null);
     }
 
     /**
-     * @param model (optional) 
+     * @param keyword (optional) 
+     * @param skipCount (optional) 
+     * @param maxResultCount (optional) 
      * @return Success
      */
-    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
-        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
+    getAll(keyword: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRoleDto> {
+        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
+        if (keyword !== undefined)
+            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
+        if (skipCount !== undefined)
+            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
+        if (maxResultCount !== undefined)
+            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
-        const content_ = JSON.stringify(model);
-
         let options_ : any = {
-            body: content_,
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
-                "Content-Type": "application/json", 
                 "Accept": "application/json"
             })
         };
 
-        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processAuthenticate(response_);
+        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processGetAll(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processAuthenticate(<any>response_);
+                    return this.processGetAll(<any>response_);
                 } catch (e) {
-                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
+                    return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
+                return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
+    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfRoleDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -2532,7 +2404,7 @@ export class TokenAuthServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
+            result200 = resultData200 ? PagedResultDtoOfRoleDto.fromJS(resultData200) : new PagedResultDtoOfRoleDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -2540,14 +2412,26 @@ export class TokenAuthServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<AuthenticateResultModel>(<any>null);
+        return _observableOf<PagedResultDtoOfRoleDto>(<any>null);
+    }
+}
+
+@Injectable()
+export class SessionServiceProxy {
+    private http: HttpClient;
+    private baseUrl: string;
+    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
+
+    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
+        this.http = http;
+        this.baseUrl = baseUrl ? baseUrl : "";
     }
 
     /**
      * @return Success
      */
-    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
-        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
+    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
+        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
         url_ = url_.replace(/[?&]$/, "");
 
         let options_ : any = {
@@ -2559,20 +2443,20 @@ export class TokenAuthServiceProxy {
         };
 
         return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetExternalAuthenticationProviders(response_);
+            return this.processGetCurrentLoginInformations(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetExternalAuthenticationProviders(<any>response_);
+                    return this.processGetCurrentLoginInformations(<any>response_);
                 } catch (e) {
-                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
+                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
+                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
+    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -2583,11 +2467,7 @@ export class TokenAuthServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            if (resultData200 && resultData200.constructor === Array) {
-                result200 = [];
-                for (let item of resultData200)
-                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
-            }
+            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -2595,18 +2475,30 @@ export class TokenAuthServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
+        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
+    }
+}
+
+@Injectable()
+export class TenantServiceProxy {
+    private http: HttpClient;
+    private baseUrl: string;
+    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
+
+    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
+        this.http = http;
+        this.baseUrl = baseUrl ? baseUrl : "";
     }
 
     /**
-     * @param model (optional) 
+     * @param input (optional) 
      * @return Success
      */
-    externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
-        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
+    create(input: CreateTenantDto | null | undefined): Observable<TenantDto> {
+        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
         url_ = url_.replace(/[?&]$/, "");
 
-        const content_ = JSON.stringify(model);
+        const content_ = JSON.stringify(input);
 
         let options_ : any = {
             body: content_,
@@ -2619,20 +2511,20 @@ export class TokenAuthServiceProxy {
         };
 
         return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processExternalAuthenticate(response_);
+            return this.processCreate(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processExternalAuthenticate(<any>response_);
+                    return this.processCreate(<any>response_);
                 } catch (e) {
-                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
+                    return <Observable<TenantDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
+                return <Observable<TenantDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
+    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -2643,7 +2535,7 @@ export class TokenAuthServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
+            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -2651,56 +2543,41 @@ export class TokenAuthServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
-    }
-}
-
-@Injectable()
-export class UserServiceProxy {
-    private http: HttpClient;
-    private baseUrl: string;
-    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
-
-    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
-        this.http = http;
-        this.baseUrl = baseUrl ? baseUrl : "";
+        return _observableOf<TenantDto>(<any>null);
     }
 
     /**
-     * @param input (optional) 
+     * @param id (optional) 
      * @return Success
      */
-    create(input: CreateUserDto | null | undefined): Observable<UserDto> {
-        let url_ = this.baseUrl + "/api/services/app/User/Create";
+    delete(id: number | null | undefined): Observable<void> {
+        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
+        if (id !== undefined)
+            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
-        const content_ = JSON.stringify(input);
-
         let options_ : any = {
-            body: content_,
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
-                "Content-Type": "application/json", 
-                "Accept": "application/json"
             })
         };
 
-        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processCreate(response_);
+        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processDelete(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processCreate(<any>response_);
+                    return this.processDelete(<any>response_);
                 } catch (e) {
-                    return <Observable<UserDto>><any>_observableThrow(e);
+                    return <Observable<void>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<UserDto>><any>_observableThrow(response_);
+                return <Observable<void>><any>_observableThrow(response_);
         }));
     }
 
-    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
+    protected processDelete(response: HttpResponseBase): Observable<void> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -2709,54 +2586,49 @@ export class UserServiceProxy {
         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            let result200: any = null;
-            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
-            return _observableOf(result200);
+            return _observableOf<void>(<any>null);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<UserDto>(<any>null);
+        return _observableOf<void>(<any>null);
     }
 
     /**
-     * @param input (optional) 
+     * @param id (optional) 
      * @return Success
      */
-    update(input: UserDto | null | undefined): Observable<UserDto> {
-        let url_ = this.baseUrl + "/api/services/app/User/Update";
+    get(id: number | null | undefined): Observable<TenantDto> {
+        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
+        if (id !== undefined)
+            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
-        const content_ = JSON.stringify(input);
-
         let options_ : any = {
-            body: content_,
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
-                "Content-Type": "application/json", 
                 "Accept": "application/json"
             })
         };
 
-        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processUpdate(response_);
+        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processGet(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processUpdate(<any>response_);
+                    return this.processGet(<any>response_);
                 } catch (e) {
-                    return <Observable<UserDto>><any>_observableThrow(e);
+                    return <Observable<TenantDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<UserDto>><any>_observableThrow(response_);
+                return <Observable<TenantDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
+    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -2767,7 +2639,7 @@ export class UserServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
+            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -2775,41 +2647,51 @@ export class UserServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<UserDto>(<any>null);
+        return _observableOf<TenantDto>(<any>null);
     }
 
     /**
-     * @param id (optional) 
+     * @param keyword (optional) 
+     * @param isActive (optional) 
+     * @param skipCount (optional) 
+     * @param maxResultCount (optional) 
      * @return Success
      */
-    delete(id: number | null | undefined): Observable<void> {
-        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
-        if (id !== undefined)
-            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
+    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfTenantDto> {
+        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
+        if (keyword !== undefined)
+            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
+        if (isActive !== undefined)
+            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
+        if (skipCount !== undefined)
+            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
+        if (maxResultCount !== undefined)
+            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
         url_ = url_.replace(/[?&]$/, "");
 
         let options_ : any = {
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
+                "Accept": "application/json"
             })
         };
 
-        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processDelete(response_);
+        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processGetAll(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processDelete(<any>response_);
+                    return this.processGetAll(<any>response_);
                 } catch (e) {
-                    return <Observable<void>><any>_observableThrow(e);
+                    return <Observable<PagedResultDtoOfTenantDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<void>><any>_observableThrow(response_);
+                return <Observable<PagedResultDtoOfTenantDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processDelete(response: HttpResponseBase): Observable<void> {
+    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTenantDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -2818,46 +2700,54 @@ export class UserServiceProxy {
         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            return _observableOf<void>(<any>null);
+            let result200: any = null;
+            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
+            result200 = resultData200 ? PagedResultDtoOfTenantDto.fromJS(resultData200) : new PagedResultDtoOfTenantDto();
+            return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<void>(<any>null);
+        return _observableOf<PagedResultDtoOfTenantDto>(<any>null);
     }
 
     /**
+     * @param input (optional) 
      * @return Success
      */
-    getRoles(): Observable<ListResultDtoOfRoleDto> {
-        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
+    update(input: TenantDto | null | undefined): Observable<TenantDto> {
+        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
         url_ = url_.replace(/[?&]$/, "");
 
+        const content_ = JSON.stringify(input);
+
         let options_ : any = {
+            body: content_,
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
+                "Content-Type": "application/json", 
                 "Accept": "application/json"
             })
         };
 
-        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetRoles(response_);
+        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processUpdate(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetRoles(<any>response_);
+                    return this.processUpdate(<any>response_);
                 } catch (e) {
-                    return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(e);
+                    return <Observable<TenantDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(response_);
+                return <Observable<TenantDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleDto> {
+    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -2868,7 +2758,7 @@ export class UserServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? ListResultDtoOfRoleDto.fromJS(resultData200) : new ListResultDtoOfRoleDto();
+            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -2876,18 +2766,30 @@ export class UserServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<ListResultDtoOfRoleDto>(<any>null);
+        return _observableOf<TenantDto>(<any>null);
+    }
+}
+
+@Injectable()
+export class TokenAuthServiceProxy {
+    private http: HttpClient;
+    private baseUrl: string;
+    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
+
+    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
+        this.http = http;
+        this.baseUrl = baseUrl ? baseUrl : "";
     }
 
     /**
-     * @param input (optional) 
+     * @param model (optional) 
      * @return Success
      */
-    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
-        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
+    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
+        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
         url_ = url_.replace(/[?&]$/, "");
 
-        const content_ = JSON.stringify(input);
+        const content_ = JSON.stringify(model);
 
         let options_ : any = {
             body: content_,
@@ -2895,24 +2797,25 @@ export class UserServiceProxy {
             responseType: "blob",
             headers: new HttpHeaders({
                 "Content-Type": "application/json", 
+                "Accept": "application/json"
             })
         };
 
         return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processChangeLanguage(response_);
+            return this.processAuthenticate(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processChangeLanguage(<any>response_);
+                    return this.processAuthenticate(<any>response_);
                 } catch (e) {
-                    return <Observable<void>><any>_observableThrow(e);
+                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<void>><any>_observableThrow(response_);
+                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
         }));
     }
 
-    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
+    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -2921,51 +2824,49 @@ export class UserServiceProxy {
         let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
         if (status === 200) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
-            return _observableOf<void>(<any>null);
+            let result200: any = null;
+            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
+            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
+            return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<void>(<any>null);
+        return _observableOf<AuthenticateResultModel>(<any>null);
     }
 
     /**
-     * @param input (optional) 
      * @return Success
      */
-    changePassword(input: ChangePasswordDto | null | undefined): Observable<boolean> {
-        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
+    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
+        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
         url_ = url_.replace(/[?&]$/, "");
 
-        const content_ = JSON.stringify(input);
-
         let options_ : any = {
-            body: content_,
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
-                "Content-Type": "application/json", 
                 "Accept": "application/json"
             })
         };
 
-        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processChangePassword(response_);
+        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processGetExternalAuthenticationProviders(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processChangePassword(<any>response_);
+                    return this.processGetExternalAuthenticationProviders(<any>response_);
                 } catch (e) {
-                    return <Observable<boolean>><any>_observableThrow(e);
+                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<boolean>><any>_observableThrow(response_);
+                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
         }));
     }
 
-    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
+    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -2976,7 +2877,11 @@ export class UserServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 !== undefined ? resultData200 : <any>null;
+            if (resultData200 && resultData200.constructor === Array) {
+                result200 = [];
+                for (let item of resultData200)
+                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
+            }
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -2984,18 +2889,18 @@ export class UserServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<boolean>(<any>null);
+        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
     }
 
     /**
-     * @param input (optional) 
+     * @param model (optional) 
      * @return Success
      */
-    resetPassword(input: ResetPasswordDto | null | undefined): Observable<boolean> {
-        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
+    externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
+        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
         url_ = url_.replace(/[?&]$/, "");
 
-        const content_ = JSON.stringify(input);
+        const content_ = JSON.stringify(model);
 
         let options_ : any = {
             body: content_,
@@ -3008,20 +2913,20 @@ export class UserServiceProxy {
         };
 
         return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processResetPassword(response_);
+            return this.processExternalAuthenticate(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processResetPassword(<any>response_);
+                    return this.processExternalAuthenticate(<any>response_);
                 } catch (e) {
-                    return <Observable<boolean>><any>_observableThrow(e);
+                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<boolean>><any>_observableThrow(response_);
+                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
         }));
     }
 
-    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
+    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -3032,7 +2937,7 @@ export class UserServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 !== undefined ? resultData200 : <any>null;
+            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -3040,33 +2945,47 @@ export class UserServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<boolean>(<any>null);
+        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
+    }
+}
+
+@Injectable()
+export class UserServiceProxy {
+    private http: HttpClient;
+    private baseUrl: string;
+    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
+
+    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
+        this.http = http;
+        this.baseUrl = baseUrl ? baseUrl : "";
     }
 
     /**
-     * @param id (optional) 
+     * @param input (optional) 
      * @return Success
      */
-    get(id: number | null | undefined): Observable<UserDto> {
-        let url_ = this.baseUrl + "/api/services/app/User/Get?";
-        if (id !== undefined)
-            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
+    create(input: CreateUserDto | null | undefined): Observable<UserDto> {
+        let url_ = this.baseUrl + "/api/services/app/User/Create";
         url_ = url_.replace(/[?&]$/, "");
 
+        const content_ = JSON.stringify(input);
+
         let options_ : any = {
+            body: content_,
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
+                "Content-Type": "application/json", 
                 "Accept": "application/json"
             })
         };
 
-        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGet(response_);
+        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processCreate(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGet(<any>response_);
+                    return this.processCreate(<any>response_);
                 } catch (e) {
                     return <Observable<UserDto>><any>_observableThrow(e);
                 }
@@ -3075,7 +2994,7 @@ export class UserServiceProxy {
         }));
     }
 
-    protected processGet(response: HttpResponseBase): Observable<UserDto> {
+    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -3098,47 +3017,40 @@ export class UserServiceProxy {
     }
 
     /**
-     * @param keyword (optional) 
-     * @param isActive (optional) 
-     * @param skipCount (optional) 
-     * @param maxResultCount (optional) 
+     * @param input (optional) 
      * @return Success
      */
-    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserDto> {
-        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
-        if (keyword !== undefined)
-            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
-        if (isActive !== undefined)
-            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
-        if (skipCount !== undefined)
-            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
-        if (maxResultCount !== undefined)
-            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
+    update(input: UserDto | null | undefined): Observable<UserDto> {
+        let url_ = this.baseUrl + "/api/services/app/User/Update";
         url_ = url_.replace(/[?&]$/, "");
 
+        const content_ = JSON.stringify(input);
+
         let options_ : any = {
+            body: content_,
             observe: "response",
             responseType: "blob",
             headers: new HttpHeaders({
+                "Content-Type": "application/json", 
                 "Accept": "application/json"
             })
         };
 
-        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
-            return this.processGetAll(response_);
+        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processUpdate(response_);
         })).pipe(_observableCatch((response_: any) => {
             if (response_ instanceof HttpResponseBase) {
                 try {
-                    return this.processGetAll(<any>response_);
+                    return this.processUpdate(<any>response_);
                 } catch (e) {
-                    return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(e);
+                    return <Observable<UserDto>><any>_observableThrow(e);
                 }
             } else
-                return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(response_);
+                return <Observable<UserDto>><any>_observableThrow(response_);
         }));
     }
 
-    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfUserDto> {
+    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
         const status = response.status;
         const responseBlob = 
             response instanceof HttpResponse ? response.body : 
@@ -3149,7 +3061,7 @@ export class UserServiceProxy {
             return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
             let result200: any = null;
             let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
-            result200 = resultData200 ? PagedResultDtoOfUserDto.fromJS(resultData200) : new PagedResultDtoOfUserDto();
+            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
             return _observableOf(result200);
             }));
         } else if (status !== 200 && status !== 204) {
@@ -3157,23 +3069,405 @@ export class UserServiceProxy {
             return throwException("An unexpected server error occurred.", status, _responseText, _headers);
             }));
         }
-        return _observableOf<PagedResultDtoOfUserDto>(<any>null);
+        return _observableOf<UserDto>(<any>null);
     }
-}
-
-export class IsTenantAvailableInput implements IIsTenantAvailableInput {
-    tenancyName: string;
 
-    constructor(data?: IIsTenantAvailableInput) {
-        if (data) {
-            for (var property in data) {
-                if (data.hasOwnProperty(property))
-                    (<any>this)[property] = (<any>data)[property];
-            }
-        }
-    }
+    /**
+     * @param id (optional) 
+     * @return Success
+     */
+    delete(id: number | null | undefined): Observable<void> {
+        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
+        if (id !== undefined)
+            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
+        url_ = url_.replace(/[?&]$/, "");
 
-    init(data?: any) {
+        let options_ : any = {
+            observe: "response",
+            responseType: "blob",
+            headers: new HttpHeaders({
+            })
+        };
+
+        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processDelete(response_);
+        })).pipe(_observableCatch((response_: any) => {
+            if (response_ instanceof HttpResponseBase) {
+                try {
+                    return this.processDelete(<any>response_);
+                } catch (e) {
+                    return <Observable<void>><any>_observableThrow(e);
+                }
+            } else
+                return <Observable<void>><any>_observableThrow(response_);
+        }));
+    }
+
+    protected processDelete(response: HttpResponseBase): Observable<void> {
+        const status = response.status;
+        const responseBlob = 
+            response instanceof HttpResponse ? response.body : 
+            (<any>response).error instanceof Blob ? (<any>response).error : undefined;
+
+        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
+        if (status === 200) {
+            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
+            return _observableOf<void>(<any>null);
+            }));
+        } else if (status !== 200 && status !== 204) {
+            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
+            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
+            }));
+        }
+        return _observableOf<void>(<any>null);
+    }
+
+    /**
+     * @return Success
+     */
+    getRoles(): Observable<ListResultDtoOfRoleDto> {
+        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
+        url_ = url_.replace(/[?&]$/, "");
+
+        let options_ : any = {
+            observe: "response",
+            responseType: "blob",
+            headers: new HttpHeaders({
+                "Accept": "application/json"
+            })
+        };
+
+        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processGetRoles(response_);
+        })).pipe(_observableCatch((response_: any) => {
+            if (response_ instanceof HttpResponseBase) {
+                try {
+                    return this.processGetRoles(<any>response_);
+                } catch (e) {
+                    return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(e);
+                }
+            } else
+                return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(response_);
+        }));
+    }
+
+    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleDto> {
+        const status = response.status;
+        const responseBlob = 
+            response instanceof HttpResponse ? response.body : 
+            (<any>response).error instanceof Blob ? (<any>response).error : undefined;
+
+        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
+        if (status === 200) {
+            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
+            let result200: any = null;
+            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
+            result200 = resultData200 ? ListResultDtoOfRoleDto.fromJS(resultData200) : new ListResultDtoOfRoleDto();
+            return _observableOf(result200);
+            }));
+        } else if (status !== 200 && status !== 204) {
+            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
+            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
+            }));
+        }
+        return _observableOf<ListResultDtoOfRoleDto>(<any>null);
+    }
+
+    /**
+     * @param input (optional) 
+     * @return Success
+     */
+    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
+        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
+        url_ = url_.replace(/[?&]$/, "");
+
+        const content_ = JSON.stringify(input);
+
+        let options_ : any = {
+            body: content_,
+            observe: "response",
+            responseType: "blob",
+            headers: new HttpHeaders({
+                "Content-Type": "application/json", 
+            })
+        };
+
+        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processChangeLanguage(response_);
+        })).pipe(_observableCatch((response_: any) => {
+            if (response_ instanceof HttpResponseBase) {
+                try {
+                    return this.processChangeLanguage(<any>response_);
+                } catch (e) {
+                    return <Observable<void>><any>_observableThrow(e);
+                }
+            } else
+                return <Observable<void>><any>_observableThrow(response_);
+        }));
+    }
+
+    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
+        const status = response.status;
+        const responseBlob = 
+            response instanceof HttpResponse ? response.body : 
+            (<any>response).error instanceof Blob ? (<any>response).error : undefined;
+
+        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
+        if (status === 200) {
+            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
+            return _observableOf<void>(<any>null);
+            }));
+        } else if (status !== 200 && status !== 204) {
+            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
+            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
+            }));
+        }
+        return _observableOf<void>(<any>null);
+    }
+
+    /**
+     * @param input (optional) 
+     * @return Success
+     */
+    changePassword(input: ChangePasswordDto | null | undefined): Observable<boolean> {
+        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
+        url_ = url_.replace(/[?&]$/, "");
+
+        const content_ = JSON.stringify(input);
+
+        let options_ : any = {
+            body: content_,
+            observe: "response",
+            responseType: "blob",
+            headers: new HttpHeaders({
+                "Content-Type": "application/json", 
+                "Accept": "application/json"
+            })
+        };
+
+        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processChangePassword(response_);
+        })).pipe(_observableCatch((response_: any) => {
+            if (response_ instanceof HttpResponseBase) {
+                try {
+                    return this.processChangePassword(<any>response_);
+                } catch (e) {
+                    return <Observable<boolean>><any>_observableThrow(e);
+                }
+            } else
+                return <Observable<boolean>><any>_observableThrow(response_);
+        }));
+    }
+
+    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
+        const status = response.status;
+        const responseBlob = 
+            response instanceof HttpResponse ? response.body : 
+            (<any>response).error instanceof Blob ? (<any>response).error : undefined;
+
+        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
+        if (status === 200) {
+            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
+            let result200: any = null;
+            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
+            result200 = resultData200 !== undefined ? resultData200 : <any>null;
+            return _observableOf(result200);
+            }));
+        } else if (status !== 200 && status !== 204) {
+            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
+            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
+            }));
+        }
+        return _observableOf<boolean>(<any>null);
+    }
+
+    /**
+     * @param input (optional) 
+     * @return Success
+     */
+    resetPassword(input: ResetPasswordDto | null | undefined): Observable<boolean> {
+        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
+        url_ = url_.replace(/[?&]$/, "");
+
+        const content_ = JSON.stringify(input);
+
+        let options_ : any = {
+            body: content_,
+            observe: "response",
+            responseType: "blob",
+            headers: new HttpHeaders({
+                "Content-Type": "application/json", 
+                "Accept": "application/json"
+            })
+        };
+
+        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processResetPassword(response_);
+        })).pipe(_observableCatch((response_: any) => {
+            if (response_ instanceof HttpResponseBase) {
+                try {
+                    return this.processResetPassword(<any>response_);
+                } catch (e) {
+                    return <Observable<boolean>><any>_observableThrow(e);
+                }
+            } else
+                return <Observable<boolean>><any>_observableThrow(response_);
+        }));
+    }
+
+    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
+        const status = response.status;
+        const responseBlob = 
+            response instanceof HttpResponse ? response.body : 
+            (<any>response).error instanceof Blob ? (<any>response).error : undefined;
+
+        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
+        if (status === 200) {
+            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
+            let result200: any = null;
+            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
+            result200 = resultData200 !== undefined ? resultData200 : <any>null;
+            return _observableOf(result200);
+            }));
+        } else if (status !== 200 && status !== 204) {
+            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
+            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
+            }));
+        }
+        return _observableOf<boolean>(<any>null);
+    }
+
+    /**
+     * @param id (optional) 
+     * @return Success
+     */
+    get(id: number | null | undefined): Observable<UserDto> {
+        let url_ = this.baseUrl + "/api/services/app/User/Get?";
+        if (id !== undefined)
+            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
+        url_ = url_.replace(/[?&]$/, "");
+
+        let options_ : any = {
+            observe: "response",
+            responseType: "blob",
+            headers: new HttpHeaders({
+                "Accept": "application/json"
+            })
+        };
+
+        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processGet(response_);
+        })).pipe(_observableCatch((response_: any) => {
+            if (response_ instanceof HttpResponseBase) {
+                try {
+                    return this.processGet(<any>response_);
+                } catch (e) {
+                    return <Observable<UserDto>><any>_observableThrow(e);
+                }
+            } else
+                return <Observable<UserDto>><any>_observableThrow(response_);
+        }));
+    }
+
+    protected processGet(response: HttpResponseBase): Observable<UserDto> {
+        const status = response.status;
+        const responseBlob = 
+            response instanceof HttpResponse ? response.body : 
+            (<any>response).error instanceof Blob ? (<any>response).error : undefined;
+
+        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
+        if (status === 200) {
+            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
+            let result200: any = null;
+            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
+            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
+            return _observableOf(result200);
+            }));
+        } else if (status !== 200 && status !== 204) {
+            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
+            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
+            }));
+        }
+        return _observableOf<UserDto>(<any>null);
+    }
+
+    /**
+     * @param keyword (optional) 
+     * @param isActive (optional) 
+     * @param skipCount (optional) 
+     * @param maxResultCount (optional) 
+     * @return Success
+     */
+    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserDto> {
+        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
+        if (keyword !== undefined)
+            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
+        if (isActive !== undefined)
+            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
+        if (skipCount !== undefined)
+            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
+        if (maxResultCount !== undefined)
+            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
+        url_ = url_.replace(/[?&]$/, "");
+
+        let options_ : any = {
+            observe: "response",
+            responseType: "blob",
+            headers: new HttpHeaders({
+                "Accept": "application/json"
+            })
+        };
+
+        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
+            return this.processGetAll(response_);
+        })).pipe(_observableCatch((response_: any) => {
+            if (response_ instanceof HttpResponseBase) {
+                try {
+                    return this.processGetAll(<any>response_);
+                } catch (e) {
+                    return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(e);
+                }
+            } else
+                return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(response_);
+        }));
+    }
+
+    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfUserDto> {
+        const status = response.status;
+        const responseBlob = 
+            response instanceof HttpResponse ? response.body : 
+            (<any>response).error instanceof Blob ? (<any>response).error : undefined;
+
+        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
+        if (status === 200) {
+            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
+            let result200: any = null;
+            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
+            result200 = resultData200 ? PagedResultDtoOfUserDto.fromJS(resultData200) : new PagedResultDtoOfUserDto();
+            return _observableOf(result200);
+            }));
+        } else if (status !== 200 && status !== 204) {
+            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
+            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
+            }));
+        }
+        return _observableOf<PagedResultDtoOfUserDto>(<any>null);
+    }
+}
+
+export class IsTenantAvailableInput implements IIsTenantAvailableInput {
+    tenancyName: string;
+
+    constructor(data?: IIsTenantAvailableInput) {
+        if (data) {
+            for (var property in data) {
+                if (data.hasOwnProperty(property))
+                    (<any>this)[property] = (<any>data)[property];
+            }
+        }
+    }
+
+    init(data?: any) {
         if (data) {
             this.tenancyName = data["tenancyName"];
         }
@@ -3208,7 +3502,209 @@ export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
     state: IsTenantAvailableOutputState | undefined;
     tenantId: number | undefined;
 
-    constructor(data?: IIsTenantAvailableOutput) {
+    constructor(data?: IIsTenantAvailableOutput) {
+        if (data) {
+            for (var property in data) {
+                if (data.hasOwnProperty(property))
+                    (<any>this)[property] = (<any>data)[property];
+            }
+        }
+    }
+
+    init(data?: any) {
+        if (data) {
+            this.state = data["state"];
+            this.tenantId = data["tenantId"];
+        }
+    }
+
+    static fromJS(data: any): IsTenantAvailableOutput {
+        data = typeof data === 'object' ? data : {};
+        let result = new IsTenantAvailableOutput();
+        result.init(data);
+        return result;
+    }
+
+    toJSON(data?: any) {
+        data = typeof data === 'object' ? data : {};
+        data["state"] = this.state;
+        data["tenantId"] = this.tenantId;
+        return data; 
+    }
+
+    clone(): IsTenantAvailableOutput {
+        const json = this.toJSON();
+        let result = new IsTenantAvailableOutput();
+        result.init(json);
+        return result;
+    }
+}
+
+export interface IIsTenantAvailableOutput {
+    state: IsTenantAvailableOutputState | undefined;
+    tenantId: number | undefined;
+}
+
+export class RegisterInput implements IRegisterInput {
+    name: string;
+    surname: string;
+    userName: string;
+    emailAddress: string;
+    password: string;
+    captchaResponse: string | undefined;
+
+    constructor(data?: IRegisterInput) {
+        if (data) {
+            for (var property in data) {
+                if (data.hasOwnProperty(property))
+                    (<any>this)[property] = (<any>data)[property];
+            }
+        }
+    }
+
+    init(data?: any) {
+        if (data) {
+            this.name = data["name"];
+            this.surname = data["surname"];
+            this.userName = data["userName"];
+            this.emailAddress = data["emailAddress"];
+            this.password = data["password"];
+            this.captchaResponse = data["captchaResponse"];
+        }
+    }
+
+    static fromJS(data: any): RegisterInput {
+        data = typeof data === 'object' ? data : {};
+        let result = new RegisterInput();
+        result.init(data);
+        return result;
+    }
+
+    toJSON(data?: any) {
+        data = typeof data === 'object' ? data : {};
+        data["name"] = this.name;
+        data["surname"] = this.surname;
+        data["userName"] = this.userName;
+        data["emailAddress"] = this.emailAddress;
+        data["password"] = this.password;
+        data["captchaResponse"] = this.captchaResponse;
+        return data; 
+    }
+
+    clone(): RegisterInput {
+        const json = this.toJSON();
+        let result = new RegisterInput();
+        result.init(json);
+        return result;
+    }
+}
+
+export interface IRegisterInput {
+    name: string;
+    surname: string;
+    userName: string;
+    emailAddress: string;
+    password: string;
+    captchaResponse: string | undefined;
+}
+
+export class RegisterOutput implements IRegisterOutput {
+    canLogin: boolean | undefined;
+
+    constructor(data?: IRegisterOutput) {
+        if (data) {
+            for (var property in data) {
+                if (data.hasOwnProperty(property))
+                    (<any>this)[property] = (<any>data)[property];
+            }
+        }
+    }
+
+    init(data?: any) {
+        if (data) {
+            this.canLogin = data["canLogin"];
+        }
+    }
+
+    static fromJS(data: any): RegisterOutput {
+        data = typeof data === 'object' ? data : {};
+        let result = new RegisterOutput();
+        result.init(data);
+        return result;
+    }
+
+    toJSON(data?: any) {
+        data = typeof data === 'object' ? data : {};
+        data["canLogin"] = this.canLogin;
+        return data; 
+    }
+
+    clone(): RegisterOutput {
+        const json = this.toJSON();
+        let result = new RegisterOutput();
+        result.init(json);
+        return result;
+    }
+}
+
+export interface IRegisterOutput {
+    canLogin: boolean | undefined;
+}
+
+export class ChangeUiThemeInput implements IChangeUiThemeInput {
+    theme: string;
+
+    constructor(data?: IChangeUiThemeInput) {
+        if (data) {
+            for (var property in data) {
+                if (data.hasOwnProperty(property))
+                    (<any>this)[property] = (<any>data)[property];
+            }
+        }
+    }
+
+    init(data?: any) {
+        if (data) {
+            this.theme = data["theme"];
+        }
+    }
+
+    static fromJS(data: any): ChangeUiThemeInput {
+        data = typeof data === 'object' ? data : {};
+        let result = new ChangeUiThemeInput();
+        result.init(data);
+        return result;
+    }
+
+    toJSON(data?: any) {
+        data = typeof data === 'object' ? data : {};
+        data["theme"] = this.theme;
+        return data; 
+    }
+
+    clone(): ChangeUiThemeInput {
+        const json = this.toJSON();
+        let result = new ChangeUiThemeInput();
+        result.init(json);
+        return result;
+    }
+}
+
+export interface IChangeUiThemeInput {
+    theme: string;
+}
+
+export class ContactCreateOrEditDto implements IContactCreateOrEditDto {
+    firstName: string;
+    lastName: string;
+    email: string;
+    stateId: number;
+    tenantId: number | undefined;
+    isActive: boolean | undefined;
+    titleId: number | undefined;
+    id: number | undefined;
+
+    constructor(data?: IContactCreateOrEditDto) {
         if (data) {
             for (var property in data) {
                 if (data.hasOwnProperty(property))
@@ -3219,47 +3715,72 @@ export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
 
     init(data?: any) {
         if (data) {
-            this.state = data["state"];
+            this.firstName = data["firstName"];
+            this.lastName = data["lastName"];
+            this.email = data["email"];
+            this.stateId = data["stateId"];
             this.tenantId = data["tenantId"];
+            this.isActive = data["isActive"];
+            this.titleId = data["titleId"];
+            this.id = data["id"];
         }
     }
 
-    static fromJS(data: any): IsTenantAvailableOutput {
+    static fromJS(data: any): ContactCreateOrEditDto {
         data = typeof data === 'object' ? data : {};
-        let result = new IsTenantAvailableOutput();
+        let result = new ContactCreateOrEditDto();
         result.init(data);
         return result;
     }
 
     toJSON(data?: any) {
         data = typeof data === 'object' ? data : {};
-        data["state"] = this.state;
+        data["firstName"] = this.firstName;
+        data["lastName"] = this.lastName;
+        data["email"] = this.email;
+        data["stateId"] = this.stateId;
         data["tenantId"] = this.tenantId;
+        data["isActive"] = this.isActive;
+        data["titleId"] = this.titleId;
+        data["id"] = this.id;
         return data; 
     }
 
-    clone(): IsTenantAvailableOutput {
+    clone(): ContactCreateOrEditDto {
         const json = this.toJSON();
-        let result = new IsTenantAvailableOutput();
+        let result = new ContactCreateOrEditDto();
         result.init(json);
         return result;
     }
 }
 
-export interface IIsTenantAvailableOutput {
-    state: IsTenantAvailableOutputState | undefined;
+export interface IContactCreateOrEditDto {
+    firstName: string;
+    lastName: string;
+    email: string;
+    stateId: number;
     tenantId: number | undefined;
+    isActive: boolean | undefined;
+    titleId: number | undefined;
+    id: number | undefined;
 }
 
-export class RegisterInput implements IRegisterInput {
-    name: string;
-    surname: string;
-    userName: string;
-    emailAddress: string;
-    password: string;
-    captchaResponse: string | undefined;
+export class ContactListViewDto implements IContactListViewDto {
+    title: OptionListItemViewDto | undefined;
+    titleId: number | undefined;
+    titleDisplay: string | undefined;
+    firstName: string;
+    lastName: string;
+    email: string;
+    state: OptionListItemViewDto | undefined;
+    stateId: number;
+    stateDisplay: string | undefined;
+    tenantId: number;
+    isActive: boolean | undefined;
+    displayName: string | undefined;
+    id: number | undefined;
 
-    constructor(data?: IRegisterInput) {
+    constructor(data?: IContactListViewDto) {
         if (data) {
             for (var property in data) {
                 if (data.hasOwnProperty(property))
@@ -3270,54 +3791,88 @@ export class RegisterInput implements IRegisterInput {
 
     init(data?: any) {
         if (data) {
-            this.name = data["name"];
-            this.surname = data["surname"];
-            this.userName = data["userName"];
-            this.emailAddress = data["emailAddress"];
-            this.password = data["password"];
-            this.captchaResponse = data["captchaResponse"];
+            this.title = data["title"] ? OptionListItemViewDto.fromJS(data["title"]) : <any>undefined;
+            this.titleId = data["titleId"];
+            this.titleDisplay = data["titleDisplay"];
+            this.firstName = data["firstName"];
+            this.lastName = data["lastName"];
+            this.email = data["email"];
+            this.state = data["state"] ? OptionListItemViewDto.fromJS(data["state"]) : <any>undefined;
+            this.stateId = data["stateId"];
+            this.stateDisplay = data["stateDisplay"];
+            this.tenantId = data["tenantId"];
+            this.isActive = data["isActive"];
+            this.displayName = data["displayName"];
+            this.id = data["id"];
         }
     }
 
-    static fromJS(data: any): RegisterInput {
+    static fromJS(data: any): ContactListViewDto {
         data = typeof data === 'object' ? data : {};
-        let result = new RegisterInput();
+        let result = new ContactListViewDto();
         result.init(data);
         return result;
     }
 
     toJSON(data?: any) {
         data = typeof data === 'object' ? data : {};
-        data["name"] = this.name;
-        data["surname"] = this.surname;
-        data["userName"] = this.userName;
-        data["emailAddress"] = this.emailAddress;
-        data["password"] = this.password;
-        data["captchaResponse"] = this.captchaResponse;
+        data["title"] = this.title ? this.title.toJSON() : <any>undefined;
+        data["titleId"] = this.titleId;
+        data["titleDisplay"] = this.titleDisplay;
+        data["firstName"] = this.firstName;
+        data["lastName"] = this.lastName;
+        data["email"] = this.email;
+        data["state"] = this.state ? this.state.toJSON() : <any>undefined;
+        data["stateId"] = this.stateId;
+        data["stateDisplay"] = this.stateDisplay;
+        data["tenantId"] = this.tenantId;
+        data["isActive"] = this.isActive;
+        data["displayName"] = this.displayName;
+        data["id"] = this.id;
         return data; 
     }
 
-    clone(): RegisterInput {
+    clone(): ContactListViewDto {
         const json = this.toJSON();
-        let result = new RegisterInput();
+        let result = new ContactListViewDto();
         result.init(json);
         return result;
     }
 }
 
-export interface IRegisterInput {
-    name: string;
-    surname: string;
-    userName: string;
-    emailAddress: string;
-    password: string;
-    captchaResponse: string | undefined;
+export interface IContactListViewDto {
+    title: OptionListItemViewDto | undefined;
+    titleId: number | undefined;
+    titleDisplay: string | undefined;
+    firstName: string;
+    lastName: string;
+    email: string;
+    state: OptionListItemViewDto | undefined;
+    stateId: number;
+    stateDisplay: string | undefined;
+    tenantId: number;
+    isActive: boolean | undefined;
+    displayName: string | undefined;
+    id: number | undefined;
 }
 
-export class RegisterOutput implements IRegisterOutput {
-    canLogin: boolean | undefined;
+export class OptionListItemViewDto implements IOptionListItemViewDto {
+    optionListId: number | undefined;
+    optionListDisplayName: string | undefined;
+    displayText: string;
+    additionalInfo: string | undefined;
+    displayOrder: number | undefined;
+    isActive: boolean | undefined;
+    isDeleted: boolean | undefined;
+    deleterUserId: number | undefined;
+    deletionTime: moment.Moment | undefined;
+    lastModificationTime: moment.Moment | undefined;
+    lastModifierUserId: number | undefined;
+    creationTime: moment.Moment | undefined;
+    creatorUserId: number | undefined;
+    id: number | undefined;
 
-    constructor(data?: IRegisterOutput) {
+    constructor(data?: IOptionListItemViewDto) {
         if (data) {
             for (var property in data) {
                 if (data.hasOwnProperty(property))
@@ -3328,39 +3883,79 @@ export class RegisterOutput implements IRegisterOutput {
 
     init(data?: any) {
         if (data) {
-            this.canLogin = data["canLogin"];
+            this.optionListId = data["optionListId"];
+            this.optionListDisplayName = data["optionListDisplayName"];
+            this.displayText = data["displayText"];
+            this.additionalInfo = data["additionalInfo"];
+            this.displayOrder = data["displayOrder"];
+            this.isActive = data["isActive"];
+            this.isDeleted = data["isDeleted"];
+            this.deleterUserId = data["deleterUserId"];
+            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
+            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
+            this.lastModifierUserId = data["lastModifierUserId"];
+            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
+            this.creatorUserId = data["creatorUserId"];
+            this.id = data["id"];
         }
     }
 
-    static fromJS(data: any): RegisterOutput {
+    static fromJS(data: any): OptionListItemViewDto {
         data = typeof data === 'object' ? data : {};
-        let result = new RegisterOutput();
+        let result = new OptionListItemViewDto();
         result.init(data);
         return result;
     }
 
     toJSON(data?: any) {
         data = typeof data === 'object' ? data : {};
-        data["canLogin"] = this.canLogin;
+        data["optionListId"] = this.optionListId;
+        data["optionListDisplayName"] = this.optionListDisplayName;
+        data["displayText"] = this.displayText;
+        data["additionalInfo"] = this.additionalInfo;
+        data["displayOrder"] = this.displayOrder;
+        data["isActive"] = this.isActive;
+        data["isDeleted"] = this.isDeleted;
+        data["deleterUserId"] = this.deleterUserId;
+        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
+        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
+        data["lastModifierUserId"] = this.lastModifierUserId;
+        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
+        data["creatorUserId"] = this.creatorUserId;
+        data["id"] = this.id;
         return data; 
     }
 
-    clone(): RegisterOutput {
+    clone(): OptionListItemViewDto {
         const json = this.toJSON();
-        let result = new RegisterOutput();
+        let result = new OptionListItemViewDto();
         result.init(json);
         return result;
     }
 }
 
-export interface IRegisterOutput {
-    canLogin: boolean | undefined;
+export interface IOptionListItemViewDto {
+    optionListId: number | undefined;
+    optionListDisplayName: string | undefined;
+    displayText: string;
+    additionalInfo: string | undefined;
+    displayOrder: number | undefined;
+    isActive: boolean | undefined;
+    isDeleted: boolean | undefined;
+    deleterUserId: number | undefined;
+    deletionTime: moment.Moment | undefined;
+    lastModificationTime: moment.Moment | undefined;
+    lastModifierUserId: number | undefined;
+    creationTime: moment.Moment | undefined;
+    creatorUserId: number | undefined;
+    id: number | undefined;
 }
 
-export class ChangeUiThemeInput implements IChangeUiThemeInput {
-    theme: string;
+export class PagedResultDtoOfContactListViewDto implements IPagedResultDtoOfContactListViewDto {
+    totalCount: number | undefined;
+    items: ContactListViewDto[] | undefined;
 
-    constructor(data?: IChangeUiThemeInput) {
+    constructor(data?: IPagedResultDtoOfContactListViewDto) {
         if (data) {
             for (var property in data) {
                 if (data.hasOwnProperty(property))
@@ -3371,33 +3966,44 @@ export class ChangeUiThemeInput implements IChangeUiThemeInput {
 
     init(data?: any) {
         if (data) {
-            this.theme = data["theme"];
+            this.totalCount = data["totalCount"];
+            if (data["items"] && data["items"].constructor === Array) {
+                this.items = [];
+                for (let item of data["items"])
+                    this.items.push(ContactListViewDto.fromJS(item));
+            }
         }
     }
 
-    static fromJS(data: any): ChangeUiThemeInput {
+    static fromJS(data: any): PagedResultDtoOfContactListViewDto {
         data = typeof data === 'object' ? data : {};
-        let result = new ChangeUiThemeInput();
+        let result = new PagedResultDtoOfContactListViewDto();
         result.init(data);
         return result;
     }
 
     toJSON(data?: any) {
         data = typeof data === 'object' ? data : {};
-        data["theme"] = this.theme;
+        data["totalCount"] = this.totalCount;
+        if (this.items && this.items.constructor === Array) {
+            data["items"] = [];
+            for (let item of this.items)
+                data["items"].push(item.toJSON());
+        }
         return data; 
     }
 
-    clone(): ChangeUiThemeInput {
+    clone(): PagedResultDtoOfContactListViewDto {
         const json = this.toJSON();
-        let result = new ChangeUiThemeInput();
+        let result = new PagedResultDtoOfContactListViewDto();
         result.init(json);
         return result;
     }
 }
 
-export interface IChangeUiThemeInput {
-    theme: string;
+export interface IPagedResultDtoOfContactListViewDto {
+    totalCount: number | undefined;
+    items: ContactListViewDto[] | undefined;
 }
 
 export class PagedResultDtoOfOptionListViewDto implements IPagedResultDtoOfOptionListViewDto {
@@ -3558,101 +4164,6 @@ export interface IOptionListViewDto {
     id: number | undefined;
 }
 
-export class OptionListItemViewDto implements IOptionListItemViewDto {
-    optionListId: number | undefined;
-    optionListDisplayName: string | undefined;
-    displayText: string;
-    additionalInfo: string | undefined;
-    displayOrder: number | undefined;
-    isActive: boolean | undefined;
-    isDeleted: boolean | undefined;
-    deleterUserId: number | undefined;
-    deletionTime: moment.Moment | undefined;
-    lastModificationTime: moment.Moment | undefined;
-    lastModifierUserId: number | undefined;
-    creationTime: moment.Moment | undefined;
-    creatorUserId: number | undefined;
-    id: number | undefined;
-
-    constructor(data?: IOptionListItemViewDto) {
-        if (data) {
-            for (var property in data) {
-                if (data.hasOwnProperty(property))
-                    (<any>this)[property] = (<any>data)[property];
-            }
-        }
-    }
-
-    init(data?: any) {
-        if (data) {
-            this.optionListId = data["optionListId"];
-            this.optionListDisplayName = data["optionListDisplayName"];
-            this.displayText = data["displayText"];
-            this.additionalInfo = data["additionalInfo"];
-            this.displayOrder = data["displayOrder"];
-            this.isActive = data["isActive"];
-            this.isDeleted = data["isDeleted"];
-            this.deleterUserId = data["deleterUserId"];
-            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
-            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
-            this.lastModifierUserId = data["lastModifierUserId"];
-            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
-            this.creatorUserId = data["creatorUserId"];
-            this.id = data["id"];
-        }
-    }
-
-    static fromJS(data: any): OptionListItemViewDto {
-        data = typeof data === 'object' ? data : {};
-        let result = new OptionListItemViewDto();
-        result.init(data);
-        return result;
-    }
-
-    toJSON(data?: any) {
-        data = typeof data === 'object' ? data : {};
-        data["optionListId"] = this.optionListId;
-        data["optionListDisplayName"] = this.optionListDisplayName;
-        data["displayText"] = this.displayText;
-        data["additionalInfo"] = this.additionalInfo;
-        data["displayOrder"] = this.displayOrder;
-        data["isActive"] = this.isActive;
-        data["isDeleted"] = this.isDeleted;
-        data["deleterUserId"] = this.deleterUserId;
-        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
-        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
-        data["lastModifierUserId"] = this.lastModifierUserId;
-        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
-        data["creatorUserId"] = this.creatorUserId;
-        data["id"] = this.id;
-        return data; 
-    }
-
-    clone(): OptionListItemViewDto {
-        const json = this.toJSON();
-        let result = new OptionListItemViewDto();
-        result.init(json);
-        return result;
-    }
-}
-
-export interface IOptionListItemViewDto {
-    optionListId: number | undefined;
-    optionListDisplayName: string | undefined;
-    displayText: string;
-    additionalInfo: string | undefined;
-    displayOrder: number | undefined;
-    isActive: boolean | undefined;
-    isDeleted: boolean | undefined;
-    deleterUserId: number | undefined;
-    deletionTime: moment.Moment | undefined;
-    lastModificationTime: moment.Moment | undefined;
-    lastModifierUserId: number | undefined;
-    creationTime: moment.Moment | undefined;
-    creatorUserId: number | undefined;
-    id: number | undefined;
-}
-
 export class OptionListCreateOrEditDto implements IOptionListCreateOrEditDto {
     tenantId: number | undefined;
     isActive: boolean;
diff --git a/src/MGS.BoilerplateDemo.Web.Host/src/shared/service-proxies/service-proxy.module.ts b/src/MGS.BoilerplateDemo.Web.Host/src/shared/service-proxies/service-proxy.module.ts
index 6832cf5..5011e19 100644
--- a/src/MGS.BoilerplateDemo.Web.Host/src/shared/service-proxies/service-proxy.module.ts
+++ b/src/MGS.BoilerplateDemo.Web.Host/src/shared/service-proxies/service-proxy.module.ts
@@ -15,6 +15,7 @@ import * as ApiServiceProxies from './service-proxies';
         ApiServiceProxies.ConfigurationServiceProxy,
         ApiServiceProxies.OptionListServiceProxy,
         ApiServiceProxies.OptionListItemsServiceProxy,
+        ApiServiceProxies.ContactServiceProxy,
         { provide: HTTP_INTERCEPTORS, useClass: AbpHttpInterceptor, multi: true }
     ]
 })
